\documentclass[../../lecture_notes.tex]{subfiles}
\begin{document}


What methods of protecting memory from corruption by bad processes do we have?
\begin{enumerate}
 \setcounter{enumi}{0}
\item Hire better programmers
\item Enable subscript/NULL checking
	\begin{itemize}
		\item requires a language that stores array sizes
		\item conditional branches and checking make this very slow
	\end{itemize}
\item Base \& Bound Registers
	\begin{itemize}
		\item simple: only requires 2 registers
		\item good for batch environments, bad for dynamic
		\item requires contiguous memory per-process and thus can cause external \& internal fragmentation
		\item not conducive to sharing; requires repetition of code with copying for each process
	\end{itemize}
\item Segmented Memory
	\begin{itemize}
		\item a hardware table mapping indices to a (array, index)/(segment\#,  offset) pair
		\item does not require adjustment of locations
		\item still has external fragmentation
	\end{itemize}
\end{enumerate}


All of these have downsides—a better and the most common one is virtual memory. This is for a few reasons:
\begin{itemize}
	\item frees programmers from worrying about physical locations and fragmentation
	\item prevents processes from illegal memory access
	\item lets processes and threads share memory
	\item lets VM be larger than actual memory \\
		while this is technically true, it can cause rapid switching of pages (\term{thrashing})  
\end{itemize}

How does it work?

\begin{center}
\begin{tikzpicture}
\node[align=center] (VM) {\def\arraystretch{1.5}\begin{tabular}{ | c | }
	\hline
	page 0 \\
	\hline
	page 1 \\
	\hline
	page 2 \\
	\hline\\\hline
	\\\\\\\vdots\\\\\\\\
	\hline
	page v \\
	\hline
	\multicolumn{1}{c}{virtual} \\
	\multicolumn{1}{c}{memory}
\end{tabular}};
\node[align=center, right=of VM] (MM) {\def\arraystretch{1.5}\begin{tabular}{ | c | }
	\hline\\\hline\\\hline\\\hline\\\hline\\\hline\\\hline
	\multicolumn{1}{c}{memory}\\
	\multicolumn{1}{c}{map}
\end{tabular}};
	\node[align=center, right=of MM] (PM) {\def\arraystretch{1.5}\begin{tabular}{ | c | }
	\hline\\\hline\\\hline\\\hline\\\hline\\\hline\\\hline\\\hline\\\hline\\\hline
	\multicolumn{1}{c}{physical}\\
	\multicolumn{1}{c}{memory}
\end{tabular}};
\node[right=3cm of PM, cylinder, minimum height=6cm, minimum width=4cm, draw, anchor=center, rotate=90, 
	align=center] (CYL) {\huge\begin{tabular}{| c | c | c | c | c |}
		\hline & & & & \\\hline & & & & \\\hline & & & & \\\hline
		\end{tabular}};
\draw[-Latex] (VM) -- (MM); 
\draw[-Latex] (MM) -- ([yshift=-1cm] PM.west); 
\draw[-Latex] (MM) -- ([yshift=+1cm] PM.west);
 \draw[-Latex] ([yshift=-1cm] PM.east) -- ([xshift=-1.5cm, yshift=2cm] CYL.west); 
  \draw[-Latex] ([xshift=-1.5cm, yshift=2.5cm] CYL.west) --  ([yshift=2cm] PM.east);
\end{tikzpicture}
\end{center}
\if false
\begin{figure}[h!]
	\includegraphics[width=\linewidth]{vmimg}
\end{figure}
\fi
\begin{itemize} 
\item Each thread has a register \%cr3 that points to the page table/memory map.
\item The page table maps virtual addresses to physical addresses.
\end{itemize}
Note that Intel keeps the specific content format of the page table secret, but this abstraction is enough to work with.


Pages are supported by the hardware --- x86-64 has a CTRL register that stores page sizes. How do we choose the size of virtual pages?
\begin{itemize}
\item large pages $\to$ small table (saves time \& space)
\item small pages $\to$ large table (less fragmentation)
\end{itemize}

Are loops allowed? (virtual $\to$ physical $\to$ virtual)
\begin{itemize}
\item This would allow us to look at the table, so to prevent memory cheating, Linux doesn’t even let us look at the table.
\end{itemize}

How do we edit the page table then?
\begin{lstlisting}
int mmap(void *vir_addr, size_t len, int prot, int flags, int fd, off_t offset);
// returns the virtual address of the new page (not necessarily the one you give)
// flags 
// 	fixed -- do not give me an address other than what I asked for
// 	private -- other processes are not allowed to see our memory
\end{lstlisting}

What if the length is not a multiple of the page size?
\begin{itemize}
	\item this is not supported; use int getpagesize()
	\item this limits pages to INT\_MAX, so we use long sysconf() to use larger pages
\end{itemize}


Are all protections reasonable?
\begin{enumerate}
\item[rw-:] ordinary data
\item[r-\,-:] read only data such as variables marked const
\item[r-x:] code (read is given because they are open source)
\item[rwx:] dynamically generated close
	\begin{itemize}
		\item this allows buffer overflow attacks
		\item the stack is often still rwx because of legacy
	\end{itemize}
\item[-\,-\,-:] useful for catching addressing errors
	\begin{itemize}
		\item can be used for guard pages on either side of the array
		\item can be used to guard a recursive frame from modifying the base pointer in stack
		\item IS used on 0 to protect from NULL accesses
	\end{itemize}
\end{enumerate}
Note that 'x' is expensive, so low end chips with no security risk often combine 'x' with 'r'.


mmap trivia:
\begin{itemize}
\item The most common file to map is /dev/zero. This functions as an input only stream of zeroes
\begin{itemize}
	\item read --- succeed and fill page with zeroes
	\item write --- succeed without doing anything
\end{itemize}
\item Two processes cannot map to the same address at the same
\item If a file has been mapped, it will not be deleted while still mapped
\item A mapped page is not intrinsically tied to any file
\item It allows us to use dynamic linking of libraries:
\end{itemize}
\begin{lstlisting}[language=sh]
$ gcc main.c -o executable -lm;
# -lm links to math library
\end{lstlisting}

\begin{center}
\begin{tikzpicture}
\node[rectangle, minimum height=2cm, minimum width = 2cm, draw, align=center] (A1) 
	{Application\\Code\\"A"};
\node[below=0cm of A1, rectangle, fill=gray, minimum height=3cm, minimum width = 2cm, draw, align=center] (A2) 
	{Static\\Library};
\node[right=of A1, rectangle, minimum height=2cm, minimum width = 2cm, draw, align=center] (B1)
	 {Application\\Code\\"B"};
\node[below=0cm of B1, rectangle, fill=gray, minimum height=3cm, minimum width = 2cm, draw, align=center] (B2) 
	{Static\\Library};
\node[right=3cm of B2, rectangle, fill=gray, minimum height=3cm, minimum width = 2cm, draw, align=center] (C) 
	{Shared\\Library};
\node[above right=1cm and 0cm of C, rectangle, minimum height=2cm, minimum width = 2cm, draw, align=center] 
	(CL) {Application\\Code\\"A"};
\node[above left=1cm and 0cm of C, rectangle, minimum height=2cm, minimum width = 2cm, draw, align=center] 
	(CR) {Application\\Code\\"B"};
\draw[dashed] (CL.south west) -- (C.north west); \draw[dashed] (CL.south east) -- (C.north east); 
\draw[dashed] (CR.south west) -- (C.north west); \draw[dashed] (CR.south east) -- (C.north east); 
\end{tikzpicture}
\end{center}


Processes share only an image of the code they share, so the virtual addresses do not match, so how do we map virtual addresses to physical addresses?
\begin{itemize}
\item We use the \term{Global Offset Table} $\coloneqq$ rwx self-modifying code that gives the offset for machine language system calls.
\end{itemize}



\end{document}