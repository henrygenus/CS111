\documentclass[../../lecture_notes.tex]{subfiles}
\begin{document}


We need metrics for gauging the quality of API in terms of modularity:
\begin{itemize}
\item performance (interfaces and modularity hurt performance)
\item robustness (how well are errors and faults dealt with)
\item simplicity (easy to use/learn/maintain)
\item neutrality/flexibility/portability (API must make few assumptions to run on all systems)
\item evolvability (needs to be able to improve; design for iteration)
\end{itemize}


Let’s evaluate our interface for reading in the bare-metal application: \newline
\begin{center}
\begin{tikzpicture}
\node (eq) at (0,0) {\begin{lstlisting} 
void read_ide_sector(int sector, char *addr);
\end{lstlisting}};
\node[above left =0.5cm and -1.8cm of eq] (suc) {Success unclear};
\draw[->] (suc.south) -- ([xshift=0.5cm] eq.north west);
\node[above right =0.5cm and -2cm of eq] (sz) {Inflexible read size};
\draw[->] (sz.south) -- ([xshift=-0.5cm] eq.north east);
\node[below right =0.5cm and -5.45cm of eq] (kn) {Must know sector size};
\draw[->] (kn.north) -- ([xshift=0.9cm] eq.south);
\end{tikzpicture}
\end{center}


Thus it is clear that this interface has many problems; Linux has the improved interface:
\begin{lstlisting}
char *readline(int fd);
\end{lstlisting}
This is still a bad design for an operating system in many ways; we can evaluate it according to our criteria to see
\begin{itemize}[nosep]
\item Modularity:
	\begin{itemize}
	\item assumes the system does memory allocation
	\end{itemize}
\item Performance:
	\begin{itemize}
	\item unbounded work --- can be very inefficient on long lines
	\item un-batched --- large overhead on short lines
	\end{itemize}
\item Robustness:
	\begin{itemize}
	\item apps can crash on long lines
	\end{itemize}
\item Neutrality:
	\begin{itemize}
	\item forces line ending convention
	\end{itemize}
\item Simplicity
	\begin{itemize}
	\item quite simple
	\end{itemize}
\end{itemize}


Thus it is clear that we need a more flexible and powerful API which will allow us to directly access low-level hardware. Linux includes the following:
\begin{lstlisting}
// lseek shifts the read and write point, white read loads the data
off_t lseek(int fd, off_t offset, int flag);
ssize_t read(int fd, char*addr, size_t bufsize);

// these have now been implemented as one primitive:
char *pread(int fd, char *buf, size_t bufsize);
\end{lstlisting}


Ultimately, we can see that the main difference between the two API's comes down to memory allocation --- choice of API is incredibly important! Our procedure call API is not the only place where modularity is important, however; suppose we have the following source code:
\begin{lstlisting}
int factorial(int n) { return (n == 0 ? 1 : n * factorial(n-1)); }
\end{lstlisting}
and we run the following commands:
\begin{lstlisting}[language=sh, 	keywordstyle=\color{black}]
$ gcc -S -01 fact.c
$ cat fact.s
\end{lstlisting}
which results in the following output assembly code:
\begin{lstlisting}
fact:
	movl $1, %eax
	testl %edi, %edi
	ne .L8
	ret

.L8:
	pushq %rbx
	movl %edi, %ebx
 	leal -1(%edi), %edi
	call fact
	imult %ebx, %eax
	popq %rbx
	ret
\end{lstlisting}
What could go wrong? Consider a malignant actor runs the following assembly code:
\begin{lstlisting}
badfact:
	movq $0x39c54e, (%rsp)
	ret
\end{lstlisting}

We could prevent this by implementing
\term{Hard Modularity}
\begin{itemize}
\item no trust is necessary (nor often exists)
\item one (or both) modules are protected
\item avoids fate
\end{itemize}

as opposed to the currently used \term{soft modularity}
\begin{itemize}
\item the caller and callee are part of "one big happy family"
\item a cheap but unsafe approach
\item operates according to the caller/callee contract:
\end{itemize}
{\scriptsize
\def\arraystretch{1.5}
\begin{tabular}{ | p{0.5\linewidth} | p{0.5\linewidth} | }
	\hline
	\textbf{Contract} & \textbf{Violation Consequence} \\
	\hline
	Callee only modifies its own variables and variables it shares with the caller; it does not modify the stack pointer and leaves the stack the same as it was called. & Callee corrupts the caller's stack and the caller may use incorrect values in later computations.\\
	\hline
	Callee returns to the caller. & Callee gets unexpected values of loses control of the program. \\
	\hline
	Return values are stored in \%eax. & Callee will receive whichever value is in \%eax, which may be incorrect. \\
	\hline
	Caller saves values in temporary registers to stack before calling callee. & Callee may change values that caller needs and caller will receive an incorrect result. \\
	\hline
	Callee will not have a disaster that affects caller (ex: early termination). & \term{Fate Sharing}: caller will also terminate. \\
	\hline
\end{tabular}
}



We can apply modularity to all 3 of the fundamental abstractions:
\begin{enumerate}
\item Interpreters/function calls (soft)
		\begin{itemize}
			\item run untrusted module on a software “machine”
			\item have  3 components:
			\begin{enumerate}
				\item instruction reference: location of next instruction
				\item repertoire: set of actions and instructions
				\item environmental reference: tells where to find environment
			\end{enumerate}
		\end{itemize}
	\item Processors:
		\begin{itemize}
			\item a general purpose implementation of an interpreter
			\item Instruction reference is a program counter
			\item Repertoire includes ADD, SUB, CMP, and JMP; LOAD not READ
			\item Have a stack and wired environmental reference
		\end{itemize}
	\item Java Virtual Machine (utilized by SEASNET)
		\begin{itemize}
			\item Unprotected:
				\begin{enumerate}
				\item communicates via shared memory → SLOW
				\item run out of stack space
				\item functions can step on each other’s memory
				\item infinite loops
			\end{enumerate}
		\end{itemize}
\item Virtualization (hard)
	\begin{itemize}
		\item we simulate the interface of a physical object by:
			\begin{enumerate}
				\item creating many virtual objects by multiplexing one physical one
				\item creating one virtual objects by aggregating multiple physical ones
				\item implementing a virtual object from a physical one by emulation
			\end{enumerate}
		\item some hardware and assembly is involved
		\item limited to a preset service
	\end{itemize}
\item Client/Server (hard)
	\begin{itemize}
		\item Details:
			\begin{itemize}
				\item run each module on its own machine 
				\item communicate via network messages
				\item no reliance on shared state; global data is safe
			\end{itemize}
		\item Transaction is arms’ length, so errors do not propagate
			\begin{itemize}
				\item error propagation is called fate sharing
				\item since there is none, all of our errors are controlled
			\end{itemize}
			\item Client can place limit on services
			\item Encourages explicit, well defined interfaces
	\end{itemize}
\end{enumerate}

We can visualize the client/server interaction as follows:
\begin{center}
\begin{tikzpicture}
\node (C) {Client};
\node[below=4cm of C] (CT) {};
\draw (C) -- (CT)
	node[pos=0.1, left] {Put argument into message}
	node[pos=0.2] (C1) {}
	node[pos=0.4, left] {Wait for response}
	node[pos=0.7] (C2) {}
	node[pos=0.8, left] {Remove result from response}
	node[pos=0.9, left] {Check results};
\node[right=of C] (S) {Server};
\node[below=4cm of S] (ST) {};
\draw (S) -- (ST)
	node[pos=0.2, right] {Wait for request}
	node[pos=0.3] (S1) {}
	node[pos=0.4, right] {Get arguments from request and compute}
	node[pos=0.5, right] {Put result into response message}
	node[pos=0.6, right] (S2) {};
\draw (S1) -- node[above, align=center, rotate=-12] {REQUEST}(C1);
\draw (C2) -- node[above, align=center, rotate=10] {RESPONSE} (S2);
\end{tikzpicture}
\end{center}


We focus on number 2, and number 3 is covered in CS 118.
\end{document}