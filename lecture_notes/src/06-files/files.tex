\documentclass[../../lecture_notes.tex]{subfiles}
\begin{document}


Input/output have a few important properties:
\begin{itemize}
\item I/O is very slow compared to CPU operations, so adding CPU overhead is fine
\item robustness and security are the focuses
\item API must work for many types of devices
\end{itemize}

We are temped to make a complex API to handle all this, but that would make usage difficult!

WE WANT: a simple, portable API that can work with the two major I/O device types:
\begin{center}
\begin{tabular}{ c | c }
	Storage (flash, disk, etc.) & Stream(display, keyboard, etc.) \\
	\hline
	Request/Response & Spontaneous Generation \\
	Random Access & Most Recent Data \\
	Finite Size & Theoretically Infinite
\end{tabular}
\end{center}

So can we write an API that can handle both? Of course! Linux did it! How? By treating everything as a file!

But we have an issue: random access; so in addition to the standard OPEN/READ/WRITE/CLOSE, we use 
\begin{lstlisting}
off_t lseek(int fd, off_t offset, int whence);
// where whence = SEEK_START || SEEK_END || SEEK_CURR}
// returns an error if used on a stream
\end{lstlisting}

The introduces the idea of \term{API orthogonality}. We want features to be “at right angles” to each other, ie the function should be independent of the function call. For example, read() has it, but not lseek()!


Here is a non-orthogonal API for reference:
\begin{lstlisting}
int creat(const char *path, mode_t mode);
// using an open functionality requires a different function call to create a file!
\end{lstlisting}

Solution: introduce an O\_CREAT flag to open()…and we dont need creat() any more!

Similar issues arise with concurrent lseek() and read()/write(), so we have two special commands
\begin{lstlisting}
ssize_t pread(int fd, void *buf, size_t count, off_t offset);
ssize_t pwrite(int fd, const void *buf, size_t count, off_t offset);
\end{lstlisting}


BUT ORTHOGONALITY SOMETIMES FIGHTS CORRECTNESS
\begin{lstlisting}
int unlink(const char *pathname);
int rename(const char *old, const char *new);
// these two function should be independent, but can we collide the axes?
\end{lstlisting}
\begin{minipage}{0.5\linewidth}
\begin{lstlisting}
// Process 1:
open("f", O_RDONLY); 
// ...
read("f"...);
\end{lstlisting}
\end{minipage}%
\begin{minipage}{0.5\linewidth}
\begin{lstlisting}
// Process 2: 
// ...
unlink("f");
\end{lstlisting}
\end{minipage}

The read does not fail; Linux allows this by waiting to delete the file until no one has it open.

Here is an example of when a lack of modularity opens security flaws:
\begin{lstlisting}[language=sh]
# our commands:
$ touch secret
$ ls -l secret
-rw-r--r-- 0 ... secret
$ chmod 600 secret
$ ls -l secret
-rw------- 0 ... secret
$ echo $password > secret
# this is secure, right?...of course not!
# bad process:
$(sleep 100; cat) < secret
# a bad process could open it before you restrict the permission and wait!
\end{lstlisting}


As a general rule, concurrent access to a file must be managed very carefully
\begin{lstlisting}[language=sh]
$ (cat a & cat b) > file
# file becomes an aggregation of a and b
$ (cat > a & cat > b) < file
# file is split amongst a and b
\end{lstlisting}

The gap between file descriptors and files can create many such errors, including
\begin{itemize}[nosep]
\item races
\item open but unnamed files (EMFILE = too many files)
\item file descriptor leaks
\item file descriptor not open (EBADF)
\item I/O error (EIO --- this one sucks to debug because it is so vague)
\item EOF (return 0)
\item device no longer there
\item empty stream
\end{itemize}


In the case of the empty stream, we have two choices:
\begin{enumerate}[nosep]
\item hang and wait for data
\item throw EAGAIN
\end{enumerate}
But, unsurprisingly, people will be unhappy either way.


\subsection{File Descriptors}
\begin{center}
\begin{tikzpicture}
\draw[draw] (0,0) rectangle (3.5,4); \node[align=center] at (1.75, 4.5) {process table entry};
\node[align=center, text width=3cm] at (1.5, 2) (PTE1) {\begin{tabular} { r | c | c | }
		\multicolumn{1}{c} {} & \multicolumn{1}{c} {flags} & \multicolumn{1}{c} {ptr} \\
		\cline{2-3}
		fd 0: & & \\
		\cline{2-3}
		fd 1: & & \\
		\cline{2-3}
		fd 2: & & \\
		\cline{2-3}
		fd 3: & & \\
		\cline{2-3}
		\multicolumn{1}{c} {} & \multicolumn{1}{| c} {} & \multicolumn{1}{c |} {} \\
		\multicolumn{1}{c} {} & \multicolumn{2}{| c |} {$\cdots$} \\
		\multicolumn{1}{c} {} & \multicolumn{1}{| c} {} & \multicolumn{1}{c |} {} \\
		\cline{2-3}
	\end{tabular}};
\draw[draw] (0,5) rectangle (3.5,9); \node[align=center] at (1.75, 9.5) {process table entry};
\node[align=center, text width=3cm] at (1.5, 7) (PTE2) {\begin{tabular} { r | c | c | }
		\multicolumn{1}{c} {} & \multicolumn{1}{c} {flags} & \multicolumn{1}{c} {ptr} \\
		\cline{2-3}
		fd 0: & & \\
		\cline{2-3}
		fd 1: & & \\
		\cline{2-3}
		fd 2: & & \\
		\cline{2-3}
		fd 3: & & \\
		\cline{2-3}
		\multicolumn{1}{c} {} & \multicolumn{1}{| c} {} & \multicolumn{1}{c |} {} \\
		\multicolumn{1}{c} {} & \multicolumn{2}{| c |} {$\cdots$} \\
		\multicolumn{1}{c} {} & \multicolumn{1}{| c} {} & \multicolumn{1}{c |} {} \\
		\cline{2-3}
	\end{tabular}};
\node at (8, 6) (FT) {\begin{tabular} { | c | } 
	\multicolumn{1}{c}{file table} \\\hline file status flags \\\hline current file offset \\\hline v-node pointer \\\hline
	\end{tabular}};
\node at (12, 4) (VT) {\begin{tabular} { | c | } 
	\multicolumn{1}{c}{v-node table} \\\hline v-node info \\\hline i-node info \\\hdashline file size \\\hline
	\end{tabular}};
\draw[-Latex] ([yshift=0.25cm] PTE1.east) to [bend left] ([xshift=0.1cm, yshift=0.4cm] FT.west); 
\draw[-Latex] ([yshift=0.25cm] PTE2.east) to [bend left] ([xshift=0.15cm, yshift=0.5cm] FT.west);
\draw[-Latex] ([xshift=-0.15cm, yshift=-0.865cm] FT.east) to [bend left] ([xshift=0.1cm, yshift=0.4cm] VT.west);
\end{tikzpicture}
\end{center}

\begin{itemize}[nosep]
\item File descriptors are indices in a pointer table; vnode info includes “pipe/non-pipe” value
\item On fork(), a copy of the parent’s fd table is made
\item On dup(), the child’s pointer is removed, but the file remains for the parent
\item Any number of the fd table entries may be present
\end{itemize}

How do these handle a complex case like \$ cat file > output?
\begin{lstlisting}
read(fd...);
write(1...);

// the shell must manipulate file descriptors to get the output! (like so:)
pid_t p = fork();
if (p==0) {
	int fd = open("output", O_WRONLY | O_CREAT | O_TRUNC, 0666);
	dup2(fd, 1);
	close(fd); // so we do not write to the wrong file
	execlp("/usr/bin/cat", (char* []){"cat", "file", 0});
}
\end{lstlisting}

But this type of error can happen on accident as well
\begin{lstlisting}
int fd = open("/tmp/foo", O_RDWR | O_CREAT, 0600);
if (fd < 0) 
if (unlink("/tmp/foo") != 0) abort();
// this thread does not let two concurrent threads run it!
\end{lstlisting}

Linux complicates the API to provide a solution to the earlier naming problem; it provides the flag O\_EXCL that throws an error if the file already exists. But we don’t want failure…we don’t care what the name is!

SOLUTION:
\begin{lstlisting}
do {
	char buf[100];
	sprintf(buf, "tmp/foo%ld", random());
	fd = open(buf, O_RDWR | O_CREAT, 0600);
} while (fd < 0 && errno == EEXIST);
// but the temp directory could fill, and we would lose our (unlinked) file!
\end{lstlisting}

Here are a few more weird cases:
\begin{lstlisting}
$ cat f > f
# f is left empty!
$ cat < f > f
# cat is emptied
$ cat < f >> f
# infinite loop! (so long as f wasn't empty)
\end{lstlisting}

To handle these cases, we need to introduce another structure called a “Pipe”

\end{document}