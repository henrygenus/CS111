\documentclass[../../lecture_notes.tex]{subfiles}
\begin{document}


A paranoid professor wants to develop a program that displays the word count of typed input.
\subsubsection*{SPECS}
\begin{itemize}
\item desktop (non-network)
\item word = [A-Za-z]+
\item output = [0-9]+
\item program runs on boot
\end{itemize}


How does booting work? 

\subsection*{x86 Boot Procedure}


CPU RAM is cleared on reset…how can we load the program? 


We generally use EEPROM, but EEPROM is expensive and static, so we can’t hold our program or kernel there. Additionally in desktops, it is read-only and hold both firmware and the location of the software to bootstrap.


We use \term{GUID (Globally Unique Identifier)} to identify disk partitions
\begin{itemize}
\item 128-bit quantity
\item without these IDs, firmware won't know if it changed or not
\item held in GUID partition table (GPT)
\end{itemize}


The basic bootstrap loading process is:
\begin{enumerate}
\item all registers start at 0 (which means kernel mode)
\item BIOS (firmware) sets up from the EEPROM and jumps to kernel
\item the kernel sets up its own stack and preloads some text to certain domains
\end{enumerate}
The overall load order is thus \begin{center}
\begin{forest} for tree={edge={semithick, -Latex}, grow=east}
[ firmware [MBR (OS-agnostic) [VBR (OS-specific)[ kernel[ app]]]]]
\end{forest} \end{center}


We can visualize it like so:
\begin{center}
\begin{tikzpicture}[scale=0.5]
\draw[fill=black!20!blue, fill opacity=0.25, thick, draw] (2,0) rectangle (6,12); \node at (4,13) {\large RAM};
\draw[thick] (6,4) -- (2,4); \node[align=center] at (4,2) {\footnotesize BIOS};
\draw (6,7) -- (2,7) node[left] {\tiny{0x150000}};
\draw (6,10)  -- (2,10) node[left] {\tiny{0x7c00}}; \node at (15,6) {\footnotesize MBR};

\draw[thick, draw] (14,5) rectangle (26,7);
\draw[thick, fill=black!20!red, fill opacity=0.25, draw] (14,5) rectangle (16,7);
\draw[thick, fill=red!20!blue, fill opacity=0.25, draw] (18,5) rectangle (24,7 );
\node[align=center] at (21,6) {\footnotesize Very Secure \\\footnotesize Word Counter};
\node[below] at (19,5) {\tiny Sector 1200}; \node[below] at (23,5) {\tiny Sector 1244};
\node[above] at (21,7) {\large Disk};
\draw[-Latex] (15,7) to [bend right] (6.1,10); \draw[-Latex] (20,7) to [bend right] (6.1,7);

\draw[thick] (8,1) rectangle (22,3); \draw (8,3) -- (14,5); \draw (22,3) -- (16,5);
\draw[thick, fill=green!40!blue, fill opacity=0.25, draw] (8,1) rectangle (16,3);
\node at (12,2) {\scriptsize 0x86 Machine Code};
\draw[thick, fill=white!50!blue, fill opacity=0.25, draw] (16,1) rectangle (20,3);
\draw[very thin] (17,1) -- (17,3); \draw[very thin] (18,1) -- (18,3); \draw[very thin] (19,1) -- (19,3);
\node at (18,2) {\scriptsize Partition Table};
\draw[thick, fill=red!20!blue, fill opacity=0.25, draw] (20,1) rectangle (22,3);
\node[anchor=center, rotate=90] at (21,2) {\scriptsize 0xA55};
\node at (12,0.5) {\tiny 446 bytes}; \node at (18,0.5) {\tiny 64 bytes}; \node at (21,0.5) {\tiny 2 bytes};

\node[align=left, text width=12cm] at (23,12) {\textbf{\underline{Basic Input Output System Procedure}}
\begin{enumerate}[nosep]
	\item self test for zeroes (hardware sanity check)
	\item scan for MBR
	\item load MBR into 0x7c00, identified by the signature 0x55AA; 
	\item load VBR's for each device
	\item set IP to 0x7c00
\end{enumerate}};
\end{tikzpicture}
\end{center}


With this knowledge, we can write our boot software:
\subsection*{Word Count App}
\begin{lstlisting}

// this is not called; it runs on boot
void main(void) {
// we read 80 sectors of 512 bytes -- 40 KiB
for (int i = 0; i < 80, i++)
	read_ide_sector(i+100, 0x2000 + 512*i);

// jump to the first instruction
goto *0x2000;
}
\end{lstlisting}

We use the following input/output primitives:
\begin{lstlisting}
#include <sys/io.h>
// CPU send signal to disk controller via bus
// disk controller sends back data from disk
// retrieve address 'a' (bus address) from disk
// this instruction is slow because signals travel on bus
unsigned char inb(unsigned short int port) { asm("...") };
// get data from port with address "port"
void outb(unsigned char value, unsigned short int port);
// write a byte of data "value" to port "port" (hardware specific
void insl(unsigned short int port, void *addr, unsigned long int count);
// read "count" bytes from "port" to "addr"
\end{lstlisting}


The layout of the drive to be loaded is as follows:

\begin{tikzpicture}
\node[rectangle, draw, align=center, minimum width = 6em, minimum height = 4em] (1) 
	{status/cmd \\ 1f7};
\node[rectangle, draw, align=center, minimum width = 24em, minimum height = 4em, right=0cm of 1] (2)
	{sector \# \\ 1f6 - 1f3};
\node[rectangle, draw, align=center, minimum width = 6em, minimum height = 4em, right=0cm of 2] (3) 
	{status/cmd \\ 1f2};
\node[rectangle, draw, align=center, minimum width = 12em, minimum height = 4em, right=0cm of 3] (4) 
	{status/cmd \\ 1f1 - 1f0};
\end{tikzpicture}


We will load according to the following protocol: \begin{enumerate}[nosep]
	\item inb from 0x1F7 (status register) to check if controller is ready
	\item outb to 0x1F2 (parameter 1 register) to give number of sectors to be read
	\item outb to 0x1F3-0x1F6 (parameter 2 register) to give 32 bit sector offset…4 writes
	\item outb to 0x1F7 (status register) a bit pattern telling controller we want to READ
	\item inb from 0x1F7 (status register) to check if data is ready for copying
	\item insl from 0x1F0 (device cache) 128 bytes of data
\end{enumerate}


\begin{lstlisting}
void read_ide_sector(int sector, int address) {
	// poll for readiness (1)
	while ((inb(0x1F7) & 0xC0) != 40) continue;
	
	// tell the controller we want 1 sector (2)
	outb(0x1F2, 1);
	
	// tell the controller where sector is (3)
	for (int i = 0; i < 4; i++) outb(0x1F3+i, sector>>(8*i) & 0xFF);
	
	// tell the controller we want to read (0x20=READ) (4)
	outb(0x1F7, 0x20);
	
	// wait for data to be ready for copying (5)
	while ((inb(0x1F7) & 0xC0) != 40) continue;
	
	// copy 128 bytes of data to addr from cache
	insl(0x1F0, address, 128);
}
\end{lstlisting}


Now that we can do the computation, we need a function to display the result. 
\begin{itemize}
\item the screen pointer is represented by (base) + (row) + (column): [80]x[25]
\item this utilizes memory mapped IO, no programmed IO, so it is not a bottleneck
\item 16 bit quantity with low order as ASCII character and high order as appearance
\end{itemize}

Here is our code:
\begin{lstlisting}
void display(long long nwords) {
	short *screen = (short*) 0xb8000 + 80*25/2 - 80/2);
	do {
		screen[0] = (nwords % 10) + '0';
		screen[1] = 7; // gray on black
		screen -= 2;
	} while ((nwords/=10) != 10);
}
\end{lstlisting}


Now that we have built our utilities, we need the outer layer function to tie it together:
\begin{lstlisting}
// at addr 0x2000 jumped to by boot protocol
void main(void) {
	// 1TB > 2^31, so we use a 64 bit digit
	long long int nwords = 0;
	// bool for starting in the middle of a word on line
	int len, s = 50000;
	do {
		char buf[513];
		buf[512] = 0;
		len = strlen(buf);
		read_ide_sector(s++, (int) buf);
		nwords += cws(buf, len, &inword);
	} while (len == 512);
	display(nwords);
}
\end{lstlisting}

Now we only need the actual word count…
\begin{lstlisting}
int cws(char *buf, int bufsize, bool *inword) {
	int w = 0;
	for (int i = 0; i < bufsize, i++) {
		bool alpha = isalpha((unsigned char)buf[i])'
		w += alpha & !*inword;
		*inword = isalpha(buf[i]);
	}
	return w;
}
\end{lstlisting}

...and we are done! our problem has a few issues, however…
\begin{enumerate}
\item Duplication of Code \begin{itemize}
	\item BIOS must already do RAM reading, but we re-wrote it by hand
	\item Code is not easily reusable
	\end{itemize}
\item VERY special purpose—not generalizable \begin{itemize}
	\item what if we wanted to boot with UEFI instead?
	\end{itemize}
\item Inefficient \begin{itemize}
	\item We spend a long time waiting. We could use yield() instead
	\item insl() chews up the bus
	\item copy disk to CPU to RAM
	\end{itemize}
\item Faults crash the entire CPU
\end{enumerate}

We can fairly easily increase efficiency using \term{double buffering}. \\
$\coloneqq$ we load the next output data while the first is being printed

\begin{figure}[H]\centering
\begin{tikzpicture}\begin{axis} [ height=4in, width=6in,
	axis x line*=center, axis y line*=left, x axis line style={->},
	xtick style={draw=none}, xticklabels={}, ytick={-2,-1,1,2}, yticklabels={I/O, CPU, I/O, CPU},
	xmin=-5, xmax=100, ymin=-3, ymax=3,
	x label style={at={(axis description cs:1,0.5)}}, xlabel={$t$}
]
\addplot[domain=0:20] {2} node[pos=0.5, above] {initialization};
\addplot[domain=25:45] {1} node[pos=0.5, above] {sector 1};
\addplot[domain=50:70] {2} node[pos=0.5, above] {sector 1};
\addplot[domain=75:95] {1} node[pos=0.5, above] {sector 2};
\addplot[domain=0:20] {-1} node[pos=0.5, above] {initialization};
\addplot[domain=25:45] {-2} node[pos=0.5, above] {sector 1};
\addplot[domain=50:70] {-1} node[pos=0.5, above] {sector 1};
\addplot[domain=50:70] {-2} node[pos=0.5, above] {sector 2};
\addplot[domain=75:95] {-1} node[pos=0.5, above] {sector 2};
\addplot[domain=75:95] {-2} node[pos=0.5, above] {sector 3};
\end{axis} \end{tikzpicture}
\caption{single (top) vs double (bottom) buffer speed}
\end{figure}

\begin{figure}[H] \centering
\begin{tikzpicture} \begin{axis} [ height=4in, width=6in,
	axis x line*=center, axis y line*=left, x axis line style={->},
	xtick style={draw=none}, xticklabels={}, ytick={-2,-1,1,2}, yticklabels={I/O, CPU, I/O, CPU},
	xmin=-5, xmax=115, ymin=-3, ymax=3,
	x label style={at={(axis description cs:1,0.5)}}, xlabel={$t$}
]
\addplot[domain=0:20] {2} node[pos=0.5, above] {initialization};
\addplot[domain=55:70] {2} node[pos=0.5, above] {sector 1};
\addplot[domain=85:100] {2} node[pos=0.5, above] {sector 2};
\addplot[domain=25:50] {1} node[pos=0.5, above] {sector 1};
\addplot[domain=55:80] {1} node[pos=0.5, above] {sector 2};
\addplot[domain=85:110] {1} node[pos=0.5, above] {sector 3};

\addplot[domain=0:20] {-1} node[pos=0.5, above] {initialization};
\addplot[domain=45:70] {-1} node[pos=0.5, above] {sector 1};
\addplot[domain=75:100] {-1} node[pos=0.5, above] {sector 2};
\addplot[domain=25:40] {-2} node[pos=0.5, above] {sector 1};
\addplot[domain=45:60] {-2} node[pos=0.5, above] {sector 2};
\addplot[domain=75:90] {-2} node[pos=0.5, above] {sector 3};
\end{axis} \end{tikzpicture} 
\caption{fast CPU (top) vs fast I/O (bottom) double buffer speed}
\end{figure}

We can thus observe that in certain situations, double buffering nearly doubles the program speed!


The one-piece solution clearly has many faults; we don’t utilize some of our best tools:
\begin{enumerate}
\item Modularity \begin{itemize}
	\item a divide-and-conquer approach
	\item A system is divided into interacting subsystems called modules; attempts to subvert modular borders can cause effects to propagate 
	\item these modules communicate through interfaces  
	\end{itemize}
\item Abstraction \begin{itemize}
	\item the ability to treat others entirely based on external specs
	\item is based on of the quality of the interface
	\end{itemize}
\item Layering \begin{itemize}
	\item a system which has layers of modules which can only interact with modules of a distance <= 1 layer from itself
	\end{itemize}
\item Hierarchy \begin{itemize}
	\item a system which has subsystems assembled upon self-contained subsystems
	\item Contains the number of interactions between N elements to N*(N-1)           
	\end{itemize}
\item Iteration \begin{itemize}
	\item starting with a simple system which fulfills some of the spec, then adding more.        
	\item Makes it easier to catch bugs and make adjustments
	\end{itemize}
\end{enumerate}

We can defeat the repeating of code using Modularity!

But what are the benefits of this? Well...Let’s say the number of bugs in a program $\propto$ N and that the cost to fix a bug $\propto$ N , where N is the number of lines in a program. The time to debug is thus $O(N^2)$, but breaking it into K modules makes the time $O(N^2/K)$

NOTE: In reality, this is a simplification, since it assumes all bugs are 100\% local, but the generalization still applies as we approach perfect modularity

We need some metrics with which to judge the quality of modularity

\end{document}