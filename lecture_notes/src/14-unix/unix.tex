\documentclass[../../lecture_notes.tex]{subfiles}
\begin{document}



We seek to create a hybrid system that utilizes the best parts of both systems; we want to utilize both the RAM and disk space.
    
We build our file system based on the following abstraction.

\begin{center}
\begin{tikzpicture}
\draw (0,0) rectangle (16,1); \node at (8, 0.5) {Virtual File System Layer};
\draw (3,4) rectangle (5,4.5); \node at (4, 4.25) {struct test}; \node at (8, 3.75) {file descriptors}; 
\draw (3.8,3) rectangle (6.2,3.5); \node at (5, 3.25) {struct filestart}; \draw[-Latex] (4, 4) -- (5, 3.5);
\node at (2.5, 2.75) {open files}; \draw[-Latex] (3.8, 3.25) -- (2.5, 3);
\draw (5,2) rectangle (7,2.5); \node at (6, 2.25) {struct file}; \draw[-Latex] (5, 3) -- (6, 2.5);
\draw (9,2) rectangle (11,2.5); \node at (10,2.25) {struct inode}; \draw[-Latex] (7, 2.25) -- (9, 2.25);
\draw (1,-1) rectangle (7,-1.5); \node at (4, -1.25) {struct file systems}; \node at (4, -1.75) {fns};
\draw (2,-2) rectangle (3.5,-2.5); \node at (2.75, -2.25) {read}; \draw[-Latex] (4, -1.5) -- (2.75, -2);
\draw (4.5,-2) rectangle (6,-2.5); \node at (5.25, -2.25) {write}; \draw[-Latex] (4, -1.5) -- (5.25, -2);
\draw (9,-1) rectangle (15,-1.5); \node at (12, -1.25) {struct inode operations};\node at (12, -1.75) {ops};
\draw (10,-2) rectangle (11.5,-2.5); \node at (10.75, -2.25) {remove}; \draw[-Latex] (12, -1.5) -- (10.75, -2);
\draw (12.5,-2) rectangle (14,-2.5); \node at (13.25, -2.25) {unlink}; \draw[-Latex] (12, -1.5) -- (13.25, -2);
\end{tikzpicture}
\end{center}


We can then, on the virtual file system layer, implement:

\begin{center}
\begin{tikzpicture}
% LVL 1
\node (0) {Hard Disk};
\node[right=0cm of 0, minimum width=1.5cm, minimum height=1cm, rectangle, draw, align=center] (11)
	 {HD\\Record};
\node[right=0cm of 11, minimum width=4.5cm, minimum height=1cm, rectangle, draw, align=center] (12)
	 {Partition 1};
\node[right=0cm of 12, minimum width=4.5cm, minimum height=1cm, rectangle, draw, align=center] (13)
	 {Partition 2};
\node[right=0cm of 13, minimum width=4.5cm, minimum height=1cm, rectangle, draw, align=center] (14)
	 {Partition 3};
% LVL 2
\node[below=1.5cm of 11, minimum width=1.5cm, minimum height=2cm, rectangle, draw, align=center] (21)
	{Boot\\Blocks};
\node[left=0cm of 21] {Partition};
\node[right=0cm of 21, minimum width=1.5cm, minimum height=2cm, rectangle, draw, align=center] (22) 
	{Super\\Blocks};
\node[right=0cm of 22, minimum width=1.5cm, minimum height=2cm, rectangle, draw, align=center] (23) 
	{Inode\\List};
\node[right=0cm of 23, minimum width=2cm, minimum height=2cm, rectangle, draw, align=center] (24) 
	{Data\\(Files \&\\Directories)};
\node[right=0cm of 24, minimum width=1.5cm, minimum height=2cm, rectangle, draw, align=center] (25) 
	{Super\\Blocks};
\node[right=0cm of 25, minimum width=1.5cm, minimum height=2cm, rectangle, draw, align=center] (26) 
	{Inode\\List};
\node[right=0cm of 26, minimum width=2cm, minimum height=2cm, rectangle, draw, align=center] (27) 
	{Data\\(Files \&\\Directories)};
\node[right=0cm of 27, minimum width=2cm, minimum height=2cm, rectangle, align=center] (28)
	{$\cdots$};
% connect
\draw[dashed, -Latex] (13.south west) -- (21.north west); \draw[dashed, -Latex] (13.south east) -- (28.north east);
\draw [decorate,decoration={brace, amplitude=10pt, mirror},xshift=-4pt,yshift=0pt]
	(22.south west) -- (24.south east) node [black, midway, yshift=-0.2cm, below] {Cylinder Group};
\draw [decorate,decoration={brace, amplitude=10pt, mirror},xshift=-4pt,yshift=0pt]
	(25.south west) -- (27.south east) node [black, midway, yshift=-0.2cm, below] {Cylinder Group};
%LVL 3
\node[below=1.5cm of 21, minimum width=2cm, minimum height=2cm, rectangle, draw, align=center, 
	label=below:{Inum}] (31) {2};
\node[left=0cm of 31, align=center] {Inode\\List\\Table};
\node[right=0cm of 31, minimum width=6cm, minimum height=2cm, rectangle, draw, align=center, 
	label=below:{Data Block Reference}] (32) {3,7,9};
\node[right=0cm of 32, minimum width=6cm, minimum height=2cm, rectangle, draw, align=center, 
	label=below:{Meta Data}] (33) {Permissions, etc.};
% connect
\draw[dashed, -Latex] (23.south west) -- (31.north west); \draw[dashed, -Latex] (23.south east) -- (33.north east);
%LVL 4
\node[below=1.5cm of 31, minimum width=2cm, minimum height=1cm, rectangle, draw, align=center, 
	label=below:{Inum}] (41) {2};
\node[left=0cm of 41, align=center] {Directory\\List\\Table};
\node[right=0cm of 41, minimum width=2cm, minimum height=1cm, rectangle, draw, align=center, 
	label=below:{Filename}] (42) {Kernel};
\node[right=of 42, minimum width=1cm, minimum height=1cm, rectangle, draw, align=center] (43) {3};
\node[right=0cm of 43, minimum width=1cm, minimum height=1cm, rectangle, draw, align=center] (44) {4};
\node[right=0cm of 44, minimum width=1cm, minimum height=1cm, rectangle, draw, align=center] (45) {5};
\node[right=0cm of 45, minimum width=1cm, minimum height=1cm, rectangle, draw, align=center] (46) {6};
\node[right=0cm of 46, minimum width=1cm, minimum height=1cm, rectangle, draw, align=center] (47) {7};
\node[right=0cm of 47, minimum width=1cm, minimum height=1cm, rectangle, draw, align=center] (48) {8};
\node[right=0cm of 48, minimum width=1cm, minimum height=1cm, rectangle, draw, align=center] (49) {9};
% connect
\draw[dashed, -Latex] (31.south west) -- (41.north west); \draw[dashed, -Latex] (31.south east) -- (42.north east);
\draw[dashed, -Latex] (32.south west) -- (43.north west); \draw[dashed, -Latex] (32.south east) -- (49.north east);
\end{tikzpicture}
\end{center}


\subsubsection*{SECTIONS}
\begin{itemize}
\item Super Block $\coloneqq$ file system metadata including the root block number
	\begin{itemize}
		\item Block Bitmap ~ maps index to FREE (0) or ALLOCATED (1) for all blocks
		\item (in BFFS) Inode Bitmap ~ maps index to FREE (0) or ALLOCATED (1) for all inodes
	\end{itemize}
\item Inode List/Table ~ table of fixed size inode entries that store file metadata and ptr to data
\item Data ~ groups of blocks are divided into sectors
	\begin{itemize}
		\item these are actually tracks, since they can be read quickly
		\item these cylinder groups form the partitions of the file system
		\item the first directory is left empty since unlink operates on the previous
		\item a file referenced by a directory name is a hard link
	\end{itemize}
\end{itemize}


\subsection{Inodes}


\begin{center}
\begin{tikzpicture}
% DIRECTORY
\node (H0) {Directory Entry};
\node[below=0cm of H0, rectangle, minimum width=1cm, minimum height=0.5cm, fill=black!20!green, opacity=0.5, draw] (01) {};
\node[below=0cm of 01, rectangle, minimum width=1cm, minimum height=0.5cm, fill=black!20!green, opacity=0.5, draw] (02) {};
\node[below=0cm of 02, rectangle, minimum width=1cm, minimum height=0.5cm, fill=black!20!green, opacity=0.5,  draw] (03) {};
\node[below=0cm of 03, rectangle, minimum width=1cm, minimum height=0.5cm, fill=black!20!green, opacity=0.5, draw] (04) {};
\node[below=0cm of 04, rectangle, minimum width=1cm, minimum height=0.5cm, fill=gray, opacity=0.5,  draw] (05) {};
\node[below=0cm of 05, rectangle, minimum width=1cm, minimum height=0.5cm, fill=gray, opacity=0.5, draw] (06) {};
\node[below=0cm of 06, rectangle, minimum width=1cm, minimum height=0.5cm, fill=yellow!50!red, opacity=0.8, draw] (07) {};
\node[below=0cm of 07, rectangle, minimum width=1cm, minimum height=0.5cm, fill=white!50!red, opacity=0.8, draw] (08) {};
\node[below=0cm of 08, rectangle, minimum width=1cm, minimum height=0.5cm, fill=black!20!blue, opacity=0.5, draw] (09) {};
\node[below=0cm of 09, rectangle, minimum width=1cm, minimum height=0.5cm, fill=black!20!blue, opacity=0.5, draw] (091) {};
\node[below=0cm of 091, rectangle, minimum width=1cm, minimum height=0.5cm, fill=black!20!blue, opacity=0.5, draw] (092) {};
\node[below=0cm of 092, rectangle, minimum width=1cm, minimum height=0.5cm, fill=black!20!blue, opacity=0.5, draw] (093) {};
\node[below=0cm of 093, rectangle, minimum width=1cm, minimum height=0.5cm, fill=black!20!blue, opacity=0.5, draw] (094) {};
\node[below=0cm of 094, rectangle, minimum width=1cm, minimum height=0.5cm, fill=black!20!blue, opacity=0.5, draw] (095) {};
\node[below=0cm of 095, rectangle, minimum width=1cm, minimum height=0.5cm, fill=black!20!blue, opacity=0.5, draw] (096) {};
\node[below=0cm of 096, rectangle, minimum width=1cm, minimum height=0.5cm, fill=black!20!blue, opacity=0.5, draw] (097) {};
\node[below=0cm of 097, rectangle, minimum width=1cm, minimum height=0.5cm, fill=black!20!blue, opacity=0.5, draw] (098) {};
\node[below=0cm of 098, rectangle, minimum width=1cm, minimum height=0.5cm, fill=black!20!blue, opacity=0.5, draw] (099) {};

% LABELS
\node[left=0cm of 02, align=center, scale=0.5] {Inode Number\\(32 Bits)}; 
\node[left=0cm of 05, align=center, scale=0.5] {Directory Entry Length\\(16 Bits)}; 
\node[left=0cm of 07, align=center, scale=0.5] {Name Length (8 Bits)}; 
\node[left=0cm of 08, align=center, scale=0.5] {File Type (8 Bits)}; 
\node[below left=0cm and 0cm of 093, align=center, scale=0.5] {File Name\\(80 Bits)}; 

% FILE
\node[right=2cm of 06] (H1) {Inode};
\node[below=0cm of H1, rectangle, minimum width=2.25cm, minimum height=0.5cm, draw] (11) {Information};
\node[below=0cm of 11, rectangle, minimum width=2.25cm, minimum height=0.5cm, draw] (12) {1};
\node[below=0cm of 12, rectangle, minimum width=2.25cm, minimum height=0.5cm, draw] (13) {2};
\node[below=0cm of 13, rectangle, minimum width=2.25cm, minimum height=0.5cm, draw] (14) {3};
\node[below=0cm of 14, rectangle, minimum width=2.25cm, minimum height=1.5cm, draw, dashed] (15) {};
\node[below=0cm of 15, rectangle, minimum width=2.25cm, minimum height=0.5cm, draw] (16) {13};
\node[below=0cm of 16, rectangle, minimum width=2.25cm, minimum height=0.5cm, draw] (17) {14};
\node[below=0cm of 17, rectangle, minimum width=2.25cm, minimum height=0.5cm, draw] (18) {15};
\draw[-Latex] (04.south east) -- (11.north west);

% DATA BLOCKS
\node[right=0.8cm of 11] (HH) {};
\node[above=0.5cm of HH, align=center] (H) {Direct\\Data Blocks};
\node[below=0cm of H, rectangle, minimum width=1cm, minimum height=0.5cm, fill=gray, draw] (1) {};
\node[below=0.5cm of 1, rectangle, minimum width=1cm, minimum height=0.5cm, fill=gray, draw] (2) {};
\node[below=0.5cm of 2, rectangle, minimum width=1cm, minimum height=0.5cm, fill=gray, draw] (3) {};
\draw[-Latex] (12.east) -- (1.west); \draw[-Latex] (13.east) -- (2.west); \draw[-Latex] (14.east) -- (3.west);

% FILE
\node[right=2cm of 14, align=center] (H2) {Blocks of\\Pointers};
\node[below=0cm of H2, rectangle, minimum width=2.25cm, minimum height=0.5cm, draw] (21) {1};
\node[below=0cm of 21, rectangle, minimum width=2.25cm, minimum height=0.5cm, draw] (22) {2};
\node[below=0cm of 22, rectangle, minimum width=2.25cm, minimum height=0.5cm, draw, dashed] (23) {};
\node[below=0cm of 23, rectangle, minimum width=2.25cm, minimum height=0.5cm, draw] (24) {128};
\node[below=0cm of 24, rectangle, minimum width=2.25cm, minimum height=0.5cm] (25) {};
\node[below=0cm of 25, rectangle, minimum width=2.25cm, minimum height=0.5cm, draw] (26) {1};
\node[below=0cm of 26, rectangle, minimum width=2.25cm, minimum height=0.5cm, draw] (27) {2};
\node[below=0cm of 27, rectangle, minimum width=2.25cm, minimum height=0.5cm, draw, dashed] (28) {};
\node[below=0cm of 28, rectangle, minimum width=2.25cm, minimum height=0.5cm, draw] (29) {128};
\node[below=0cm of 29, rectangle, minimum width=2.25cm, minimum height=0.5cm] (25) {};
\draw[-Latex] (16.east) -- (23.north west);
\draw[-Latex] (17.east) -- (28.north west);

% DATA BLOCKS
\node[right=0.8cm of 21] (HH) {};
\node[above=0.5cm of HH, align=center] (H) {Indirect\\Data Blocks};
\node[below=0cm of H, rectangle, minimum width=1cm, minimum height=0.5cm, fill=gray, draw] (1) {};
\node[below=0.5cm of 1, rectangle, minimum width=1cm, minimum height=0.5cm, fill=gray, draw] (2) {};
\node[below=0.5cm of 2, rectangle, minimum width=1cm, minimum height=0.5cm, fill=gray, draw] (3) {};
\draw[-Latex] (21.east) -- (1.west); \draw[-Latex] (22.east) -- (2.west); \draw[-Latex] (24.east) -- (3.west);

% FILE
\node[right=2cm of 24, align=center] (H3) {Blocks of\\Pointers};
\node[below=0cm of H3, rectangle, minimum width=2.25cm, minimum height=0.5cm, draw] (31) {1};
\node[below=0cm of 31, rectangle, minimum width=2.25cm, minimum height=0.5cm, draw] (32) {2};
\node[below=0cm of 32, rectangle, minimum width=2.25cm, minimum height=0.5cm, draw, dashed] (33) {};
\node[below=0cm of 33, rectangle, minimum width=2.25cm, minimum height=0.5cm, draw] (34) {128};
\node[below=0cm of 34, rectangle, minimum width=2.25cm, minimum height=0.5cm] (35) {};
\node[below=0cm of 35, rectangle, minimum width=2.25cm, minimum height=0.5cm, draw] (36) {1};
\node[below=0cm of 36, rectangle, minimum width=2.25cm, minimum height=0.5cm, draw] (37) {2};
\node[below=0cm of 37, rectangle, minimum width=2.25cm, minimum height=0.5cm, draw, dashed] (38) {};
\node[below=0cm of 38, rectangle, minimum width=2.25cm, minimum height=0.5cm, draw] (39) {128};
\node[below=0cm of 39, rectangle, minimum width=2.25cm, minimum height=0.5cm] (35) {};
\draw[-Latex] (26.east) -- (33.north west);
\draw[-Latex] (27.east) -- (38.north west);

% DATA BLOCKS
\node[right=0.8cm of 31] (HH) {};
\node[above=0.5cm of HH, align=center] (H) {Doubly Indirect\\Data Blocks};
\node[below=0cm of H, rectangle, minimum width=1cm, minimum height=0.5cm, fill=gray, draw] (1) {};
\node[below=0.5cm of 1, rectangle, minimum width=1cm, minimum height=0.5cm, fill=gray, draw] (2) {};
\node[below=0.5cm of 2, rectangle, minimum width=1cm, minimum height=0.5cm, fill=gray, draw] (3) {};
\draw[-Latex] (31.east) -- (1.west); \draw[-Latex] (32.east) -- (2.west); \draw[-Latex] (34.east) -- (3.west);
\node[below=0.5cm of 3, rectangle, minimum width=1cm, minimum height=0.5cm, fill=gray, draw] (1) {};
\node[below=0.5cm of 1, rectangle, minimum width=1cm, minimum height=0.5cm, fill=gray, draw] (2) {};
\node[below=0.5cm of 2, rectangle, minimum width=1cm, minimum height=0.5cm, fill=gray, draw] (3) {};
\draw[-Latex] (36.east) -- (1.west); \draw[-Latex] (37.east) -- (2.west); \draw[-Latex] (39.east) -- (3.west);
\end{tikzpicture}
\end{center}


The data block array stores the block numbers of partitions of data
	\begin{itemize}
		\item 0 means the section is empty
		\item a file with many 0’s is referred to as holey
	\end{itemize}
Inode Metadata (in order):
	\begin{itemize}
		\item owner (32-bit)
		\item timestamp (last modified time)
		\item access time (mtime, sysclock)
		\item inode change (ctime)
		\item permissions
		\item file type (directory/regular file/...) (cached, since this one doesn’t change)
	\end{itemize}


There are a bunch of new problems though:
\begin{enumerate}
\item slow copying (fixed with binary trees)
\item file data is in a linked list, so parsing is slow
	\begin{itemize}
		\item thankfully, lseek() is O(1)
		\item Berkeley Fast File System addresses this with an inode bitmap held in RAM
	\end{itemize}
\item There is an arbitrary limit on the size of our file!
	\begin{itemize}
	\item a 10 block array can store 10 blocks $\times$ 8192 bytes/block = 82 kB
	\item We solve this with an indirect block which points to a block of block pointers. \\
		This adds 1023 blocks $\times$ 8192 bytes/block + 82 kB = 8 mB
	\item This is still not good enough, so we introduce a doubly indirect block. \\
		This adds $1023^2$ blocks $\times$ 8192 bytes/block = 8 GB 
	\item With a triply indirect block, we meet a decent file size ($2^{35}$ blocks = 4TB)
	\item If use a $4\times10^{12}$ byte file as a database:
		\begin{itemize}
			\item we can initialize to zero and avoid any writing
			\item space will exhaust; $4\times10^{12}$ may not represent the available space
			\item triply indirect block data takes three block accesses
		\end{itemize}
	\end{itemize}
	BUT The above inode approach causes Internal Fragmentation!
\end{enumerate}

How bad is this fragmentation?
\begin{itemize}
	\item file size = 0 blocks --- 48 bytes wasted for the inode
	\item file size = 1 blocks --- 44 bytes + 8191 bytes = 8235 bytes wasted
\end{itemize}
If we make a file in the following way:
\begin{lstlisting}
int fd = open("foo", O_CREAT | O_WRONLY | O_TRUNC, 0666);
if (lseek(fd, 1000000000, SEEK_SET)) abort();
else write(fd, "Hello", 5);
\end{lstlisting}\begin{lstlisting}[language=sh]
$  ls -l big
-rw-rw-rw- 5 ...
# the file size is still listed as 5!
# wasted 44 (inode) + 8188 (indirect) + 8198 (double) + 8187 (triple) bytes!
\end{lstlisting}


\subsection{Mounting}

\begin{center}
\resizebox{0.75\linewidth}{!}{
\begin{forest}
 basic/.style = {draw, thin, drop shadow, font=\sffamily},
	upper style/.style = {basic, rounded corners=6pt, edge+={-Stealth, thin}, fill=black!6, text width=5em},
	lower style/.style = {basic, rounded corners=0pt, edge+={-, line width=.4pt}, fill=black!10, text width=4em},
	bottom style/.style = {lower style, draw=none, fill=none, no shadows},
	where level<=3{%
		upper style,
		edge path'={
			(!u.parent anchor) -- +(0,-5pt) -| (.child anchor)
		},
	}{%
		lower style, 
		folder,
		grow'=0
	},
	where level<=2{%
		parent anchor=children,
		child anchor=parent,
		if={isodd(n_children())}{%
			calign=child edge,
			calign primary child/.process={
			O+nw+n{n children}{(#1+1)/2}
		},
		}{%
			calign=edge midpoint,
		},
	}{},
[/
	[sbin, folder, grow'=0, for children={bottom style},	 
	before drawing tree={
		tempdima/.option=!r2.max y,
		tempdima-/.option=max y,
		for tree={
			y+/.register=tempdima,
		},
	},
		[mount, folder, grow'=0]
		[rc0, folder, grow'=0]
		[shutdown, folder, grow'=0]
	]
	[etc,
    		[fs]
		[, edge={-}, coordinate
			[, coordinate, edge={-}, grow'=0, for descendants={
				bottom style, edge path'={(!u.parent anchor) |- (.child anchor)}
			}, before packing={calign primary child=2}
				[group, folder, grow'=0, tikz={\node (g) {};}]
				[system, folder, grow'=0, tikz={\node (s) {};}]
				[ttydefs, folder, grow'=0, tikz={\node (t) {};}]
			]
		]
    		[opt]
	]
	[opt, 
    		[SUNWleo]
		[unbundled, for children={upper style}, calign=edge midpoint,
		tikz={\node [draw, rectangle, fit=(!1)(!ll), label=above right:{\large File System}](R){};
			\node [above=of R] (MP) {}; \node[right=of MP] (label) {Mount Point}; \draw[-Latex] (label) -- (MP);}
			[app1, folder, grow'=0, for children={lower style},
			before drawing tree={
				tempdima/.option=!r2.max y,
				tempdima-/.option=max y,
				for tree={
					y+/.register=tempdima,
				},
	      		}
				[file1, folder, grow'=0]
				[file2, folder, grow'=0]
				[file3, folder, grow'=0]
			]
			[app2, folder, grow'=0, for children={lower style},
			before drawing tree={
				tempdima/.option=!r2.max y,
				tempdima-/.option=max y,
				for tree={
					y+/.register=tempdima,
				},
      			}
				[file1, folder, grow'=0]
				[file2, folder, grow'=0]
				[file3, folder, grow'=0]
			]
    		]
	]
]
 \end{forest}
}
\end{center}


How could we keep track of multiple file systems? We pass keeping track to the user by \term{mounting}
\begin{itemize}[nosep]
	\item choose one of the devices to be the root
	\item mount the other onto the root
\end{itemize}
The Mount Table maps a device name to its path; a device name therefore acts like a symbolic link

We identify files by inode number, but these are not shared among devices! We need a (device number, inode number) pair! namei() can resolve a name into one of these pairs, recursively, but this introduces a scalability issue!

To solve this, we COULD store pairs in the parent directory, but we want to be able to unmount and mount anywhere. The hosting filesystem should have no reference to the hosted and (more importantly) hard links cant cross devices, since devices can have different types of file system

Similarly, but not as mounting, we can put a file in “chroot jail”
\begin{lstlisting}[language=sh]
$ chroot("subdir")
# now the file can only see files below it
# to get out, we can run:

ln /usr/bin/emacs subdir/bin/emacs
ln /dev/tty subdir/dev/tty
ln /dev/dsk/00 subdir/dev/dsk/00
open /dev/dsk/00 // for rw- permissions
ln {some other file to accessible location}
\end{lstlisting}


\subsection{File Types}

UNIX supports the following file types:

\begin{center}
\def\arraystretch{1.5}
\begin{tabular} { | c | c | c | c | }
	\hline
	File Type & Symbol & Created by & Removed by \\
	\hline\hline
	Regular File & - & Editors, cp, etc. & rm \\
	\hline
	Directory & d & mkdir & rmdir, rm -f \\
	\hline
	Character device file & c & mknod & rm \\
	\hline
	Block device file & b & mknod & rm \\
	\hline
	UNIX domain socket & s & socket(2) & rm \\
	\hline
	Named pipe & p & mknod & rm \\
	\hline
	Symbolic link & l & lm -s & rm \\
	\hline
\end{tabular}
\end{center}

\subsubsection*{Symbolic Links (l)}
$\coloneqq$ a file whose contents contain another file’s name. This differs from a hard link, which maps to the inode number.

\begin{center}
\begin{tikzpicture}
\node[align=center] (L) {\begin{tabular} {| c |} 
	\multicolumn{1}{c}{d}\\\hline \\\hline \\\hline \\\hline \\\hline \\\hline \\\hline 
	\end{tabular}};
\node[align=center, right=3cm of L] (C) {\begin{tabular} {| c |} 
	\multicolumn{1}{c}{e}\\\hline \\\hline \\\hline \\\hline \\\hline \\\hline \\\hline 
	\end{tabular}};
\node[align=center, right=3cm of C] (R) {};
\node[align=center, above=2cm of R] (R1) {\begin{tabular} {| c |} 
	\hline I am symlink \\\hline "d/a" \\\hline \\\hline\end{tabular}};
\node[align=center, below=3cm of R1] (R2) {\begin{tabular} {| c |} 
	\multicolumn{1}{c}{inode}\\\hline\\\hline\\\hline\\\hline\end{tabular}};
\node[align=center, right=2cm of R2] (F) {\begin{tabular} {| c |} 
	\multicolumn{1}{c}{data block}\\\hline\\\hline\end{tabular}};	
\node[align=center, right=0cm of F] {hard link};
\draw[-Latex] (L.east) to [bend right] (R2.west); \draw[-Latex] (R2.east) -- (F.west);
\draw[-Latex] (C.east) to [bend left] (R1.west); \draw[-Latex] (C.east) to [bend right] (R2.west);
\end{tikzpicture}
\end{center}


File names are resolved recursively by namei(). As such, symlinks can introduce problems
\begin{lstlisting}[language=sh]
# ex 1)
$ ln -s . loop
$ ls -l loop
/loop/loop/loop/......

# ex 2) (assume . is 'd')
$ ln -s .. loop
$ ls -l loop
/loop/d/loop/......
\end{lstlisting}

How do we resolve this?
\begin{itemize}
\item find, grep, and similar operations do not follow symlinks
\item namei() has a depth limit on recursions
\end{itemize}
\begin{lstlisting}
$ ln -s linkloop linkloop
$ cat linkloop
# sets errno and returns -1!
\end{lstlisting}


\subsubsection*{Device Drivers (b||c)}
both character and block devices are windows into a drive
\begin{itemize}
	\item character --- stream-ish
	\item block --- storage-ish (read \& write are limited to a fixed size)
\end{itemize}
For example: the serial port driver sends and receives bytes by wire.
\begin{lstlisting}[language=sh]
$ mknod /dev/ser1 c 59 23
# mknod --- make node
# /dev/ser1 --- path to device
# c --- character
# 59 23 --- device ID
\end{lstlisting}

These form the basis of file systems! They are antiquated, but common in IOT devices, which dont use an OS.

These drivers suggest users can access data outside of establishes guidelines. In fact, root can access memory and read and write by path!

Knowing this, how can we protect our data?
\begin{lstlisting}
# we want to protect our proposal
$ rm prop.txt
# the file is gone right? NOPE: if there were links, it doesn't get deleted
$ (rm prop.txt; ckst) < prop.txt
# (ckst is self defined to check link count) 
# what if someone was already reading it?
$ chmod 700 .
# they could still get into the directory by stealing our disk!
$ shred prop.txt
# overwrite our data 2-3 times with random data
# BUT the OS may have copied the data elsewhere
$ shred /dev/ds2b
# we shred our entire file system!
# but what if another device copied it?
\end{lstlisting}
MELT THE DRIVE
(seriously…even physical shredding leaves readable magnetic residue)


Since apps generally use block writing/perform writes on the block level, the block driver sees a large set of requests; how does it schedule these? We have a few algorithm choices:
\begin{enumerate}
\item SHORTEST SEEK TIME FIRST
	\begin{enumerate}
		\item perform the shortest seek first
		\item maximal throughput
		\item very unfair --- allows starvation
	\end{enumerate}
\item FIRST COME, FIRST SERVED
	\begin{enumerate}
		\item perform the oldest seek first
		\item low throughput
		\item very fair
	\end{enumerate}
\item ELEVATOR
	\begin{enumerate}
		\item a hybrid approach 
		\item perform the closest request in a set direction
		\item good throughput
		\item prioritizes locations near the center
	\end{enumerate}
	we can use a non-snaking path to avoid this
\end{enumerate}
BUT these algorithms are designed for disks! What can we do for blocks? (which don’t have the same seek time?
\begin{enumerate}
\item[(4)] Anticipatory Scheduling
	\begin{itemize}
		\item is done at the OS or controller level
		\begin{itemize}
		\item naively: $$\{P1, 1000, P2\} \implies P1, 1000, P2$$
		\item anticipatory: $$\{P1, 1000\} \rightarrow \{1000\} \rightarrow \text{ dally } \rightarrow \{P2, 1000\} \rightarrow \{1000\} \implies P1, P2, 1000$$
		\end{itemize}
	\end{itemize}
	A write cannot be switched with a read/write to the same location.
\end{enumerate}

This introduces a new set of risks.


\end{document}