\documentclass[../../lecture_notes.tex]{subfiles}
\begin{document}


We like loading into RAM; it is fast BUT this is the recipe for races.

Say I want to keep track of my money:
\begin{lstlisting}
bool deposit(int amt) {
	if (amt < 0 || INT_MAX - amt > balance) return false;
	balance += amt;
	return true;
}
bool withdraw(int amt) {
	if (amt < 0 || balance - amt > 0) return false;
	balance += amt;
	return true;
}
\end{lstlisting}


This is a TERRIBLE implementation
\begin{itemize}[nosep]
\item if two threads try to deposit at the same time, one may be ignored
\item an interrupt during the += can cause an ignore
\end{itemize}


This is a mistake in synchronization, which can occur in:
\begin{itemize}
\item a single CPU with preemptive scheduling
\item a single thread with interrupt handling
\item a multiple CPU system
\end{itemize}

We call these errors caused by concurrent access \term{race conditions} $\coloneqq$ pieces of code which can cause race conditions are called \term{critical sections}. If we can make critical sections atomic at the point of observability, we can say that the actions are serializable, or the same result could be found by running the operations sequentially.

We have atomicity iff we have:
\begin{enumerate}[label=(\roman*)]
\item Mutual Exclusion $\coloneqq$ one thread in the critical section excludes all others
\item Bounded Wait $\coloneqq$ eventually, waiting threads will be able to enter the critical section
\end{enumerate}


There are a few major complications that we must guarantee atomicity around:
\begin{enumerate}[label=(\roman*)]
\item Preemptive Scheduling \\
	we may be interrupted mid critical section and leave in an invalid state
\item Threads \\
	a thread might be kicked out while others are running and leave the others to utilize an invalid state
\end{enumerate}

The \term{Goldilocks principle} for critical sections:
If everyone only reads, then everyone is safe; only writes cause problems. Therefore when searching for critical sections, we repeatedly
\begin{enumerate}
\item look for shared writes (each of the shared writes should be in a critical sectIon)
\item expand to include dependent reads and intervening computation
\end{enumerate}
\begin{lstlisting}
// new_balance dependent on balance
long long new_balance = balance + amt; 
balance = new_balance;
\end{lstlisting}


Guaranteeing these rules is hardâ€¦we can avoid it with a few tricks:
\begin{enumerate}
\item Single-Threaded Code
\item Event-Driven Programming
	\begin{itemize}
	\item useful for when we have 1 CPU and many threads
	\item of the form: \\
	for(;;) \{ \\
		wait for an event; \\
		act on that event; \\
	\}
	\item acting on E must be fast enough as to avoid any waiting
	\item common in IOT appliances
	\item Downsides:
	\begin{itemize}
		\item code is restricted
		\item no true parallelism
		\item too easy to be interesting 
	\end{itemize}
	\end{itemize}
\item Synchronization via Load \& Store \\
	the size of objects is restricted:
	\begin{itemize}[nosep]
		\item no large objects! (copying takes multiple cycles and is not atomic)
		\item no small objects! (writing less than a byte still copies the whole byte first)
	\end{itemize}
	Therefore we can use only objects of 1 byte, since that is the granularity of x86-64 copy.
\end{enumerate}


We can also have synchronization errors without any critical sections whatsoever:
\begin{lstlisting}
// thread 1
for (long i = 0; i < n; i++) continue
// thread 2
...
n = 0;
// i is only copied once! s trying to force thread 1 to stop waiting fails 
// we must use the keyword 'volatile' to require copying from memory each time
\end{lstlisting}

To guarantee atomicity, we must introduce the concept of locks!


\end{document}