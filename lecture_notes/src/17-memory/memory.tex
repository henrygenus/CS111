\documentclass[../../lecture_notes.tex]{subfiles}
\begin{document}


When utilizing virtual memory, we often have to deal with \term{page faults} $\coloneqq$ the failure of the hardware’s rule for page lookup because:
\begin{enumerate}[label=(\alph*), nosep]
	\item the user lacks the permissions to access the page
	\item the page is invalid
	\item the page does not exist
\end{enumerate}

The hardware attempts to look the page up in the page table using the index of the form

\begin{center}
\begin{tikzpicture}
\node[rectangle, minimum width=3cm, minimum height=1cm, draw] (L1) {Level 1};
\node[right=0cm of L1, rectangle, minimum width=3cm, minimum height=1cm, draw] (L2) {Level 2};
\node[right=0cm of L2, rectangle, minimum width=3cm, minimum height=1cm, draw] (L3) {Level 3};
\node[right=0cm of L3, rectangle, minimum width=3cm, minimum height=1cm, draw] (O1) {Offset};
\node[below=of L1, circle, minimum size=1cm, draw] (+1) {+};
\node[below=2cm of L2, circle, minimum size=1cm, draw] (+2) {+};
\node[below=3cm of L3, circle, minimum size=1cm, draw] (+3) {+};
\node[below right=0.5cm and 0cm of +1, align=center] (PTE1) {\begin{tabular} {| c |} 
	\hline\\\hline\\PTE\\\hline\\$\vdots$\\\hline\end{tabular}};
\node[below right=0.5cm and 0cm of +2, align=center] (PTE2) {\begin{tabular} {| c |} 
	\hline\\\hline\\PTE\\\hline\\$\vdots$\\\hline\end{tabular}};
\node[below right=0.5cm and 0cm of +3, align=center] (PTE3) {\begin{tabular} {| c |} 
	\hline\\\hline\\PTE\\\hline\\$\vdots$\\\hline\end{tabular}};
\node[below right=1cm and -0.5cm of O1, rectangle, minimum width=2cm, minimum height=1cm, draw](FR){Frame};
\node[right=0cm of FR, rectangle, minimum width=2cm, minimum height=1cm, draw] (O2) {Offset};
\node[left=0.5cm of +1, rectangle, minimum width=2cm, minimum height=1cm, draw] (PTBR) {PTBR};
\draw[-Latex] (L1) -- (+1); \draw[-Latex] (L2) -- (+2); \draw[-Latex] (L3) -- (+3); 
\draw[-Latex] (+1) -- +(0,-1) |- (PTE1); \draw[-Latex] (+2) -- +(0,-1) |- (PTE2); \draw[-Latex] (+3) -- +(0,-1) |- (PTE3);
\draw[-Latex] (PTE1) -- +(1, 0) |- (+2); \draw[-Latex] (PTE2) -- +(1, 0) |- (+3);
\draw[-Latex] (PTE3) -- +(1, 0) -| (FR); \draw[-Latex] (O1) -- +(0, -1) -| (O2);
\draw[-Latex] (PTBR) -- (+1); 
\end{tikzpicture}
\end{center}


Which then finds the page like so


\begin{center}
\begin{tikzpicture}
\node[align=center] (LM) {\def\arraystretch{1.5}\begin{tabular}{ r | c | }
	\cline{2-2}
	0 & A \\
	\cline{2-2}
	1 & B \\
	\cline{2-2}
	2 & C \\
	\cline{2-2}
	3 & D \\
	\cline{2-2}
	4 & E \\
	\cline{2-2}
	5 & F \\
	\cline{2-2}
	6 & G \\
	\cline{2-2}
	7 & H \\
	\cline{2-2}
	\multicolumn{1}{c}{ } & \multicolumn{1}{c}{\small logical} \\
	\multicolumn{1}{c}{ } & \multicolumn{1}{c}{\small memory}
\end{tabular}
};
\node[right=of LM, align=center] (PT) {\def\arraystretch{1.5}\begin{tabular}{ r | c | c | }
	\cline{2-3}
	0 & 4 & v \\
	\cline{2-3}
	1 &  & i \\
	\cline{2-3}
	2 & 6 & v \\
	\cline{2-3}
	3 & & i \\
	\cline{2-3}
	4 & & i \\
	\cline{2-3}
	5 & 9 & v \\
	\cline{2-3}
	6 & & i \\
	\cline{2-3}
	7 & & i \\
	\cline{2-3}
	\multicolumn{1}{c}{ } & \multicolumn{1}{c}{\small page} \\
	\multicolumn{1}{c}{ } & \multicolumn{1}{c}{\small table} \\
\end{tabular}
};
\node[above left=0.25cm and -0.5cm of PT] (fr) {frame}; \draw[-Latex] (fr) -- (PT.north);
\node[above right=0.25cm and -1cm of PT, align=center] (vi) {valid/invalid\\bit}; \draw[-Latex] (vi) -- (PT);
\node[right=of PT, align=center] (PM) {\def\arraystretch{1.5}\begin{tabular}{ r | c | }
	\cline{2-2}
	0 &  \\
	\cline{2-2}
	1 &  \\
	\cline{2-2}
	2 &  \\
	\cline{2-2}
	3 &  \\
	\cline{2-2}
	4 & A \\
	\cline{2-2}
	5 &  \\
	\cline{2-2}
	6 & C \\
	\cline{2-2}
	7 &  \\
	\cline{2-2}
	8 &  \\
	\cline{2-2}
	9 &  F \\
	\cline{2-2}
	10 & \\
	\cline{2-2}
	11 & \\
	\cline{2-2}
	12 & \\
	\cline{2-2}
	13 & \\
	\cline{2-2}
	14 & \\
	\cline{2-2}
	15 & \\
	\cline{2-2}
	\multicolumn{1}{c}{ } & \multicolumn{1}{c}{\small physical} \\
	\multicolumn{1}{c}{ } & \multicolumn{1}{c}{\small memory}
\end{tabular}
};
\node [right=3cm of PM, align=center, cylinder, minimum height=6cm, minimum width=3cm, rotate=90, anchor=center, draw] (CYL) {\rotatebox{-90}{\def\arraystretch{1.25}\begin{tabular}{ | c | c | c | }
	\hline & & \\\hline & A & B \\\hline C & D & E \\\hline F & G & H \\\hline & & \\\hline\end{tabular}}};
\end{tikzpicture}
\end{center}

But if the page is not in memory, we have a page fault! The page fault is treated like any other fault:
\begin{itemize}
	\item the OS looks in the interrupt source vector (aka trap table) and jumps to indicated page; note that we could end up trapped if this page faults as well
	\item The kernel has a few options on a page fault
	\begin{enumerate}[nosep]
		\item the kernel level fix: assume the program is buggy and kill it
		\item the program level fix: arrange the stack as if there were no fault and send signal
		\item the data level fix: change the page table entry and jump before the fault (the slowest)
	\end{enumerate}
\end{itemize}

\begin{center}
\begin{tikzpicture}
\node[rectangle, minimum width=1cm, minimum height=2cm, draw, align=center] (OS) {operating\\system};
\node[below right=of OS, rectangle, fill=blue!30, minimum width=1.25cm, minimum height=0.75cm, draw, align=right] 
	(PT1) {};
\node[below=0cm of PT1, rectangle, fill=gray!60, minimum width=1.25cm, minimum height=0.75cm, draw, align=right] 
	(PT2) {\;\;\;\;\;$\mid$ i};
\node[below=0cm of PT2, rectangle, fill=blue!30, minimum width=1.25cm, minimum height=0.75cm, draw, align=right] (PT3) {};
\node[left=of PT2, rectangle, minimum width=1cm, minimum height=2cm, fill=gray!60, draw, align=center] (LOAD) {load M};
\node[right=of PT3, rectangle, fill=blue!30, minimum width=2cm, minimum height=0.5cm, draw,
	label=below:{page table}] (PM1) {};
\node[below=0cm of PM1, rectangle, fill=blue!30, minimum width=2cm, minimum height=0.5cm, draw] (PM2) {};
\node[below=0cm of PM2, rectangle, fill=gray!60, minimum width=2cm, minimum height=0.5cm, draw, align=right] (PM*) {free frame};
\node[below=0cm of PM*, rectangle, fill=blue!30, minimum width=2cm, minimum height=0.5cm, draw] (PM3) {};
\node[below=0cm of PM3, rectangle, fill=blue!30, minimum width=2cm, minimum height=0.5cm, draw] (PM4) {};
\node[below=0cm of PM4, rectangle, fill=blue!30, minimum width=2cm, minimum height=0.5cm, draw] (PM5) {};
\node[below=0cm of PM5, rectangle, fill=blue!30, minimum width=2cm, minimum height=0.5cm, draw] (PM6) {};
\node[below=0cm of PM6, rectangle, fill=blue!30, minimum width=2cm, minimum height=0.5cm, draw,
	label=below:{physical memory}] (PM7) {};
\node[right=1.5cm of PM1, cylinder, minimum width=2cm, minimum height=4cm, fill=blue!30, rotate=90, draw] 
	(CYL) {};
\node[rectangle, draw, fill=white] at (CYL.center) (M) {};
\draw [-Latex] (PT2.east) -- +(1,0) |- node[pos=0.25, right] {\scriptsize 2. trap} ([yshift=-0.5cm] OS.east);
\draw [-Latex] (PT2) -- node[pos=0.45, above=-0.025cm] {\scriptsize 6. run} (LOAD); 
\draw [-Latex] ([yshift=0.375cm] LOAD.east) -- node[pos=0.5, above] {\scriptsize 1. ref} (PT2.north west);
\draw [-Latex] (PM*.west) -- node[pos=0.5, below] {\scriptsize 5. reset page table} +(-3,0) |- (PT2.south west);
\draw [-Latex] ([yshift=0.5cm] OS.east) -- node[pos=0.5, above] {\scriptsize 3. find page on disk} +(4,0) -- (M);
\draw [-Latex] (M.south) -- +(0, -1) |- node[pos=0.5, below] {\scriptsize 4. load page} (PM*.east);
\draw ([yshift=0.25cm] LOAD.north west) -- ([yshift=-2cm] LOAD.south west);
\draw ([yshift=0.25cm] LOAD.north east) -- ([yshift=-2cm] LOAD.south east);
\end{tikzpicture}
\end{center}

\if false
\begin{figure}[h!]
	\centering
	\includegraphics[height=0.5\linewidth, width=0.75\linewidth]{pageswap}
\end{figure}
\fi
The third option is called \term{paging}; we use it to simulate a big machine on a small one (for instance).

The kernel memory where the physical pages are cached from the disk is the \term{swap space}.

\subsection{Page Replacement}
\begin{lstlisting}
// we assume that we have implemented the following functions:
int swapmap(int process, int virtual_address);
// this returns the disk address in the swap space or FAIL
tuple (process, va) removal_policy()
// this returns the process and virtual address of the next victim page
int pmap(int va);
// refers to the physical address mapped to by a given virtual

void pfault(int va, int proc, int access_type...) {
	if (swapmap(proc, va) == FALL) kill(proc);
	else {
		(vic_proc, vic_va) = removal_policy();
		int vic_pa = vic_proc->pmap(vic_va);
		vic_proc->pmap(vic_va) = FAIL;
		/// write vic_pa to flash at location swapmap(vic_proc, vic_va)
		// read vic_pa from flash at location swapmap(proc, va)
        proc->pmap(va) = pa;
      }
    }
\end{lstlisting}

How do we decide the removal policy? We need some heuristic for when to swap a page:
\begin{enumerate}[label=(\alph*), nosep]
	\item Nobody needs the page (and there is no dynamic linkage to it)
	\item Page has not changed since load (and therefore RAM data is valid)
	\item Page is not needed for a while (based on an approximation
\end{enumerate}


Here follows a few simple page replacement policies:

\subsubsection*{ORACLE}
\begin{figure}[H]
\centering
\begin{tikzpicture}
\node [align=center] (c) {\begin{tabular}{c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c}
	7 & 0 & 1 & 2 & 0 & 3 & 0 & 4 & 2 & 3 & 0 & 3 & 2 & 1 & 2 & 0 & 1 & 7 & 0 & 1 
	\end{tabular}};
\node [below=0cm of c, scale=0.9] (pf) {\begin{tabular}{ | c || c || c || c || c || c || c || c || c || c || c || c || c || c || c || c || c || c || c || c || c || c || c || c || c || c || c || c || c || c || c || c || c || c || c || c | }
	\hline
	7 & 7 & 7 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 7 & 7 \\
	\hline
	& 0 & 0 & 0 & 0 & 0 & 0 & 4 & 4 & 4 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
	\hline
	& & 1 & 1 & 1 & 3 & 3 & 3 & 3 & 3 & 3 & 3 & 3 & 1 & 1 & 1 & 1 & 1 & 1 \\
	\hline
	\end{tabular}};
\node [above=0cm of c] {reference string};
\node [below=0cm of pf] {page frames};
\end{tikzpicture}
\caption{9 replacements}
\end{figure}


\subsubsection*{FIRST IN, FIRST OUT}

\begin{figure}[H]
\centering
\begin{tikzpicture}
\node [align=center] (c) {\begin{tabular}{c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c}
	7 & 0 & 1 & 2 & 0 & 3 & 0 & 4 & 2 & 3 & 0 & 3 & 2 & 1 & 2 & 0 & 1 & 7 & 0 & 1 
	\end{tabular}};
\node [below=0cm of c, scale=0.9] (pf) {\begin{tabular}{ | c || c || c || c || c || c || c || c || c || c || c || c || c || c || c || c || c || c || c || c || c || c || c || c || c || c || c || c || c || c || c || c || c || c || c || c | }
	\hline
	7 & 7 & 7 & 2 & 2 & 2 & 2 & 4 & 4 & 4 & 0 & 0 & 0 & 0 & 0 & 0 & 7 & 7 & 7 \\
	\hline
	& 0 & 0 & 0 & 0 & 3 & 3 & 3 & 2 & 2 & 2 & 2 & 2 & 1 & 1 & 1 & 1 & 0 & 0 \\
	\hline
	& & 1 & 1 & 1 & 1 & 0 & 0 & 0 & 3 & 3 & 3 & 3 & 3 & 2 & 2 & 2 & 2 & 1 \\
	\hline
	\end{tabular}};
\node [above=0cm of c] {reference string};
\node [below=0cm of pf] {page frames};
\end{tikzpicture}
\caption{15 replacements}
\end{figure}

Note that with FIFO, increasing the number of pages increases the number of replacements; this is called \term{Beladay’s Anomaly}, and it occurs because FIFO is not a \term{stack algorithm} (ie the state of a smaller cache at any point is not a subset of the larger cache),

FIFO is easy to implement, since the table is in the kernel and the kernel retrieves pages; we just keep a table of when each page was brought into RAM.


\subsubsection*{LEAST RECENTLY USED}

\begin{figure}[H]
\centering
\begin{tikzpicture}
\node [align=center] (c) {\begin{tabular}{c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c}
	7 & 0 & 1 & 2 & 0 & 3 & 0 & 4 & 2 & 3 & 0 & 3 & 2 & 1 & 2 & 0 & 1 & 7 & 0 & 1 
	\end{tabular}};
\node [below=0cm of c, scale=0.9] (pf) {\begin{tabular}{ | c || c || c || c || c || c || c || c || c || c || c || c || c || c || c || c || c || c || c || c || c || c || c || c || c || c || c || c || c || c || c || c || c || c || c || c | }
	\hline
	7 & 7 & 7 & 2 & 2 & 2 & 2 & 4 & 4 & 4 & 0 & 0 & 0 & 1 & 1 & 1 & 1 & 1 & 1 \\
	\hline
	& 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 3 & 3 & 3 & 3 & 3 & 3 & 0 & 0 & 0 & 0 \\
	\hline
	& & 1 & 1 & 1 & 3 & 3 & 3 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 7 & 7 \\
	\hline
	\end{tabular}};
\node [above=0cm of c] {reference string};
\node [below=0cm of pf] {page frames};
\end{tikzpicture}
\caption{12 replacements}
\end{figure}


LRU is more difficult to implement, since the kernel does not take over on each access and therefore has no chance to edit the last accessed time. We can address this in one of a few ways:
\begin{enumerate}
\item get hardware support
	\begin{itemize}
		\item this is slow and rarely used
	\end{itemize}
\item periodic invalidation
	\begin{itemize}
		\item Procedure:
		        \begin{enumerate}[nosep]
				\item the kernel periodically invokes a timer fault to mark all pages as invalid
				\item any succeeding access will then cause a fault which allows the kernel to update times
			\end{enumerate}
		\item for clock precision, this is done in hardware after about a second passes. The time choice is important: \begin{itemize}
			\item a long gap means less interruption
			\item a short gap means better approximation
		\end{itemize}
	\end{itemize}
\end{enumerate}

Possible Optimizations:
\begin{enumerate}
\item Demand Paging
	\begin{itemize}
		\item Procedure:
			\begin{enumerate}[label=\arabic*.]
				\item start with no pages in RAM
				\item c startup routine (cstrt()) causes initial fault
				\item call to main causes a second fault
			\end{enumerate}
		\item This strives to lessen wait time by skipping unnecessary copies
			\begin{itemize}
				\item best case: we only need the two pages
				\item worst case: we need all the pages. This performs worse than the standard approach since it prevents us from batch copying.
			\end{itemize}
	\end{itemize}
\item Copy on Write
	\begin{itemize}
		\item only give processes read permission and do not copy entries write is attempted
		\item this is done by vfork() to get the benefit of threading without race conditions
		\item vfork() is equivalent to fork, except:
		\begin{enumerate}[label=(\roman*), nosep]
			\item Parent and child can share memory.
			\item Parent is frozen and cannot run until child either exits or execs
		\end{enumerate}
	\end{itemize}
\item Dirty Bit
	\begin{itemize}
		\item a special bit in a page table entry indicates whether the page has been modified.
		\item The bit is set to 1 if it has been modified since last load, 0 if not
		\item we only need write a victim to memory if the dirty bit is 1
		\item often implemented by making pages O\_RDONLY so that the first access is a fault
		\item sometimes implemented using the clock algorithm, which works like the elevator
	\end{itemize}
	\begin{center}
	\resizebox{.5\textwidth}{!}{
		\begin{tikzpicture}
		\node[align=center] (L) {reference\\bits};
		\node[below=of L, rectangle, minimum size=1cm, draw] (1) {0};
		\node[below=of 1, rectangle, minimum size=1cm, draw] (2) {0};
		\node[below=of 2, rectangle, minimum size=1cm, draw] (3) {1};
		\node[below=of 3, rectangle, minimum size=1cm, draw] (4) {1};
		\node[below=of 4, rectangle, minimum size=1cm, draw] (5) {0};
		\node[below=of 5, rectangle, minimum size=1cm, draw] (6) {1};
		\node[below=of 6, rectangle, minimum size=1cm, draw] (7) {1};
		\node[left=of 3, align=center] (arr) {next\\victim}; \draw[-Latex] (arr) -- (3); \draw[dotted] (5) -- (6);

		\node[right=of L, align=center] (R) {pages};
		\node[below=of R, rectangle, minimum size=1cm, draw] (1) {};
		\node[below=of 1, rectangle, minimum size=1cm, draw] (2) {}; \draw[-Latex] (1) -- (2);
		\node[below=of 2, rectangle, minimum size=1cm, draw] (3) {}; \draw[-Latex] (2) -- (3);
		\node[below=of 3, rectangle, minimum size=1cm, draw] (4) {}; \draw[-Latex] (3) -- (4);
		\node[below=of 4, rectangle, minimum size=1cm, draw] (5) {}; \draw[-Latex] (4) -- (5);
		\node[below=of 5, rectangle, minimum size=1cm, draw] (6) {}; \draw[-Latex] (5) -- (6);
		\node[below=of 6, rectangle, minimum size=1cm, draw] (7) {}; \draw[-Latex] (6) -- (7);
		\node[right=of 4] (m) {}; \draw[dotted] (5) -- (6); 
		\draw[rounded corners] (7.south) -- +(0, -1) -- +(1, -1) -| (m.center);
		\draw[Latex-, rounded corners] (1.north) -- +(0, 1) -- +(1, 1) -| (m.center);

		\node[right=6cm of L, align=center] (L) {reference\\bits};
		\node[below=of L, rectangle, minimum size=1cm, draw] (1) {0};
		\node[below=of 1, rectangle, minimum size=1cm, draw] (2) {0};
		\node[below=of 2, rectangle, minimum size=1cm, draw] (3) {0};
		\node[below=of 3, rectangle, minimum size=1cm, draw] (4) {0};
		\node[below=of 4, rectangle, minimum size=1cm, draw] (5) {0};
		\node[below=of 5, rectangle, minimum size=1cm, draw] (6) {1};
		\node[below=of 6, rectangle, minimum size=1cm, draw] (7) {1};
		\node[left=of 5, align=center] (arr) {next\\victim}; \draw[-Latex] (arr) -- (5); \draw[dotted] (5) -- (6);

		\node[right=of L, align=center] (R) {pages};
		\node[below=of R, rectangle, minimum size=1cm, draw] (1) {};
		\node[below=of 1, rectangle, minimum size=1cm, draw] (2) {}; \draw[-Latex] (1) -- (2);
		\node[below=of 2, rectangle, minimum size=1cm, draw] (3) {}; \draw[-Latex] (2) -- (3);
		\node[below=of 3, rectangle, minimum size=1cm, draw] (4) {}; \draw[-Latex] (3) -- (4);
		\node[below=of 4, rectangle, minimum size=1cm, draw] (5) {}; \draw[-Latex] (4) -- (5);
		\node[below=of 5, rectangle, minimum size=1cm, draw] (6) {}; \draw[-Latex] (5) -- (6);
		\node[below=of 6, rectangle, minimum size=1cm, draw] (7) {}; \draw[-Latex] (6) -- (7);
		\node[right=of 4] (m) {}; \draw[dotted] (5) -- (6); 
		\draw[rounded corners] (7.south) -- +(0, -1) -- +(1, -1) -| (m.center);
		\draw[Latex-, rounded corners] (1.north) -- +(0, 1) -- +(1, 1) -| (m.center);
		\end{tikzpicture}
		}
	\end{center}
\end{enumerate}


\end{document}