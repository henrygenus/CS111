\documentclass[../../lecture_notes.tex]{subfiles}
\begin{document}


To discuss risks like this, we need to define a few key terms;
\begin{itemize}
\item error $\coloneqq$ a mistake by the designer or user
\item fault $\coloneqq$ a latent problem in design
\item failure $\coloneqq$ the problem caused when the fault trap springs
\item durability $\coloneqq$ the system’s ability for data to survive limited failure
\item atomicity
	\begin{enumerate}
		\item \term{All-or-Nothing Atomicity}
			\begin{itemize}
				\item From the point of view of a function’s invoker, the sequence either:
					\begin{enumerate}
						\item Completes
						\item Aborts such that it appears the action was never started (back out)
					\end{enumerate}
				\item How can we give the READ function AoN atomicity?
					\begin{enumerate}
						\item \term{Blocking Read}: wait and sets return address before READ
						\item \term{Non-Blocking Read}: kernel returns {} if stream is empty
						\item Non-Atomic: READ waits and blocks until char is delivered
					\end{enumerate}
			\end{itemize}
		\item \term{Before-or-After Atomicity}
			\begin{itemize}
				\item From the view of a function’s invokers, the result is the same as if the actions occurred completely before or completely after one another
				\item If two actions have before or after atomicity, they are \term{serializable} $\coloneqq$ there exists some serial order of those concurrent actions that would, if followed, lead to the same ending state
			\end{itemize}
		\item \term{Sequential/external time consistency} 
			\begin{itemize} 
				\item If it appears to the outside that the events occurred in a certain order, the correct result is as if they were executed in this orders. 
				\item This is only required in some cases.
			\end{itemize}
	\end{enumerate}
\end{itemize}

So take a test editor, say EMACS, and assume it is writing to blocks; what happens if the power goes out while we are overwriting our data? This leads us to our Golden Rule of Atomicity: never delete your only copy.

\begin{center}
\begin{tikzpicture}
\node at (-0.5, 1.25) {F1}; \node at (-0.5, 2.25) {F2}; \node at (-0.5, 0.4575) {\scriptsize marker}; 
\draw (0, 0) rectangle (2, 3); 
\draw (0.75, 0.25) rectangle (1.25, 0.675); \node at (1, 0.4575) {1}; 
\draw (0.5, 1) rectangle (1.5, 1.5); \node at (1, 1.25) {?}; 
\draw (0.5, 2) rectangle (1.5, 2.5); \node at (1, 2.25) {X}; 
\draw[-Latex] (2, 1.5) -- (5,1.5);

\draw (5, 0) rectangle (7, 3); 
\draw (5.75, 0.25) rectangle (6.25, 0.675); \node at (6, 0.4575) {2}; 
\draw (5.5, 1) rectangle (6.5, 1.5); \node at (6, 1.25) {Y}; 
\draw (5.5, 2) rectangle (6.5, 2.5); \node at (6, 2.25) {X}; 
\draw[-Latex] (7, 1.5) -- (10,1.5);

\draw (10, 0) rectangle (12, 3); 
\draw (10.75, 0.25) rectangle (11.25, 0.675); \node at (11, 0.4575) {1}; 
\draw (10.5, 1) rectangle (11.5, 1.5); \node at (11, 1.25) {Y}; 
\draw (10.5, 2) rectangle (11.5, 2.5); \node at (11, 2.25) {Y}; 
\end{tikzpicture}
\end{center}


Our first attempt at atomicity: we create a new file and write the new data there; on completion we switch which is the active file. \begin{itemize}
\item But what if we lost power mid-swap?  We wouldn’t know which is the active data? \\
	We can solve this in a probabilistic sense with checksums post fail 
\item But what if it a block write isn’t atomic? Write from A to B is 3 stages: A $\to$ ? $\to$ B \\ 
	We can make an atomic write using 3 blocks!
\end{itemize}


\begin{minipage}{0.6\linewidth}
\begin{center}
\begin{tabular}{ c | c | c | c | c | c | c | c | }
	\multicolumn{8}{c}{File Data Contents} \\
	\cline{2-8}
	F1 & A & ? & B & B & B & B & B \\
	\cline{2-8}
	F2 & A & A & A & ? & B & B & B \\
	\cline{2-8}
	F3 & A & A & A & A & A & ? & B \\
	\cline{2-8}
	\multicolumn{8}{c}{time $\to$}
\end{tabular}
\end{center}
\end{minipage}%
\begin{minipage}{0.4\linewidth}
Algorithm:
\begin{enumerate}[nosep]
	\item write 3 in series
	\item use best 2/3 to choose
	\item choose block 0 if they all differ
\end{enumerate}
\end{minipage}


Since we have atomic block write, we can discuss file system robustness on a larger scale:

We use a Lampion-Sturgis failure model:
\begin{enumerate}[nosep]
	\item storage writes may fail
	\item storage writes may corrupt other blocks
	\item storage blocks may decay spontaneously
	\item a read can detect a bad block (using checksums)
	\item errors are rare
	\item reports can be done in time
\end{enumerate}

We also need to establish a few file system robustness invariants:
\begin{enumerate}
\item every block serves at most one purpose --- failure allows a program to overwrite another program’s data
\item all referenced blocks are properly initialized --- failure allows an uninitialized block to look like a pointer to a random block
\item all referenced blocks are marked as “used” -- failure allows data to be overwritten
\item all non-referenced blocks are marked as “free” --- failure leaves an unused block marked as used $\to$ data leak
\end{enumerate}
The failure of most of these would mean the loss of data—except number 4, so our failure hinges on number 4.


Take a risky operation…say rename(“d/a”, “e/b”)
\begin{itemize}
\item fsck() will catch our erros, but it is insanely slow!
\item It prioritizes the inode data and moves unreferenced inodes to a lost \& found
\item File permissions are set to kernel only
\end{itemize}

This could be done in one of a few ways:

\begin{minipage}{0.5\linewidth}
BAD Algorithm:
\begin{enumerate}[nosep]
	\item block a $\to$ RAM
	\item block b $\to$ RAM
	\item update blocks
	\item block a $\to$ flash
	\item block b $\to$ flash
\end{enumerate}
\end{minipage}%
\begin{minipage}{0.5\linewidth}
GOOD Algorithm:
\begin{enumerate}[nosep]
	\item read block a into RAM
	\item read inode into RAM
	\item read block b into RAM
	\item update blocks and increment link count
	\item write inode to flash
	\item write b to flash
	\item write a to flash
	\item link count -= 1 and write inode to flash
\end{enumerate}
\end{minipage}


BAD: \begin{itemize}
	\item Failure between 4 \& 5 would lose data!
\end{itemize}

GOOD: \begin{itemize}
	\item Instruction (5-6): only old link exists but lc = 2
	\item Instruction (6-7): the old and new copy exist and lc = 2
	\item Instruction (7-8): only new link exists but lc = 2
\end{itemize}
The good one is better because we would prefer to lose space over data!


We can now look at abstracting a single block write into multiple blocks:

\subsubsection{COMMIT RECORDS}
\begin{itemize}
	\item document writes such that writes are atomic
	\item put commit records and all writes into a well recognized location
\end{itemize}


\subsubsection{JOURNALING}
\begin{minipage}{0.5\linewidth}
{\centering\subsubsection*{Journal}}
\begin{center}
\begin{tikzpicture}
\node[rectangle, minimum width=4cm, minimum height=1cm, draw] (0){$\cdots$};
\node[right=0cm of 0, rectangle, minimum width=1cm, minimum height=1cm, draw] (1) {A'};
\node[right=0cm of 1, rectangle, minimum width=1cm, minimum height=1cm, draw] (2) {B'};
\node[right=0cm of 2, rectangle, minimum width=1cm, minimum height=1cm, draw] (3) {CR};
\node[right=0cm of 3, rectangle, minimum width=1cm, minimum height=1cm, draw] (4) {DR};
\end{tikzpicture}
\end{center}
Algorithm:
\begin{enumerate}[nosep]
	\item Write A' to journal
	\item Write B' to journal
	\item Write CR to journal (BEGIN)
	\item Copy A' to cell storage (CHANGEA)
	\item Copy B' to cell storage (CHANGEB)
	\item Write DR to journal (OUTCOME)
\end{enumerate}
We then reorganize, and we're done.
\end{minipage}%
\begin{minipage}{0.5\linewidth}
{\centering\subsubsection*{Cell Storage}}
\begin{center}
\begin{tikzpicture}
\node[rectangle, minimum width=1cm, minimum height=1cm, draw] (1) {};
\node[right=0cm of 1, rectangle, minimum width=1cm, minimum height=1cm, draw] (2) {};
\node[right=0cm of 2, rectangle, minimum width=1cm, minimum height=1cm, draw] (3) {};
\node[right=0cm of 3, rectangle, minimum width=1cm, minimum height=1cm, draw] (4) {B};
\node[below=0cm of 1, rectangle, minimum width=1cm, minimum height=1cm, draw] (1) {};
\node[right=0cm of 1, rectangle, minimum width=1cm, minimum height=1cm, draw] (2) {A};
\node[right=0cm of 2, rectangle, minimum width=1cm, minimum height=1cm, draw] (3) {};
\node[right=0cm of 3, rectangle, minimum width=1cm, minimum height=1cm, draw] (4) {};
\node[below=0cm of 1, rectangle, minimum width=1cm, minimum height=1cm, draw] (1) {};
\node[right=0cm of 1, rectangle, minimum width=1cm, minimum height=1cm, draw] (2) {};
\node[right=0cm of 2, rectangle, minimum width=1cm, minimum height=1cm, draw] (3) {};
\node[right=0cm of 3, rectangle, minimum width=1cm, minimum height=1cm, draw] (4) {};
\end{tikzpicture}
\end{center}
Consequences of Failure:
\begin{enumerate}[nosep, align=left]
\item[Pre BEGIN:] No effect.
\item[Post BEGIN:] Never initiated.
\item[Post OUTCOME:] Write Complete.
\end{enumerate}
\end{minipage}


We keep cells in RAM and only copy to disk on write
	\begin{enumerate}[nosep]
		\item[-] Wastes storage and will eventually run off disks
		\item[+] Solves many inconsistency problems
		\item[+] If mostly writing, avoids seeks
	\end{enumerate}


Since we can fail during reboot, our recovery strategy must also be \term{idempotent}, $\coloneqq$ execution one time is the same as executing any number of times.

We have to write each entry twice…what if we do a large write?  Failure seems likely.
\begin{enumerate} 
	\item[$\implies$] this is true, but most apps think between writes, so long writes are rare. 
\end{enumerate}

What do we do if a directory is replaced with a file \& there is a crash?
\begin{itemize}
	\item Linux uses the idea of “revoke records” to record a negative change in extv4
	\item Linux also writes
\end{itemize}


Is this viable for flash? 
\begin{enumerate} 
	\item[No]  — the performance benefit of this is that we ignore seek costs for write, but we know where we are going to write here.
\end{enumerate}
    

We have two major journaling options: (the example uses write-ahead)

\begin{figure}[H]
\begin{subfigure}[t]{0.5\linewidth}
\subsubsection*{Write Ahead (ext4 option)}
\begin{enumerate}[nosep]
\item log changes in data
\item write changes in data
\item write the commit record
\item write the done record
\end{enumerate}
RECOVERY:
\begin{itemize}
\item replay commit records
\end{itemize}
DOWNSIDE:
\begin{itemize}
\item the start of our replay can be hard to find
\end{itemize}
BENEFITS:
\begin{itemize}
\item more likely to save last action
\item do not need to keep multiple versions
\end{itemize}
\end{subfigure}
~
\begin{subfigure}[t]{0.5\linewidth}
\subsubsection*{Write Behind}
\begin{enumerate}[nosep]
\item log old data values
\item write the commit record
\item write changes in data
\item write the done record
\end{enumerate}
RECOVERY:
\begin{itemize}
\item undo the changes
\end{itemize}
DOWNSIDE:
\begin{itemize}
\item we must copy all of our data on each write
\end{itemize}
BENEFITS:
\begin{itemize}
\item old data cached $\implies$ small pre-write benefit
\item more conservative $\implies$ more recovery
\item no data searching $\implies$ faster recovery
\end{itemize}
\end{subfigure}
\end{figure}


We need to be able to handle the failure of low level operations. We describe two interactions:
\begin{enumerate}
\item cascading aborts
	\begin{itemize}
	\item if a low level operation fails, the high level one fails
	\item very automate-able
	\item Example: Write-Ahead Protocol Cascading Abort:
		\begin{enumerate}
			\item While logging planned writes, error occurs
			\item Abort record
			\item Send cascading aborts to higher level functions.
		\end{enumerate}
	\end{itemize}
\item compensating actions
	\begin{itemize}
		\item if a low level operation fails, the higher one makes up for it
		\item very flexible
		\item Example: Write-Ahead Protocol Compensating Action:
		\begin{enumerate}
			\item Log planned writes
			\item Commit record
			\item While writing to disk, error occurs. After reboot compensating actions continue writing to cell memory using data written in the log.
		\end{enumerate}
	\end{itemize}
\end{enumerate}

There are many different types of corruption which can occur in a file system:
\begin{enumerate}
\item gamma rays can flip a bit
	\begin{itemize}
		\item this happens roughly once a week
		\item ECC memory with a parity bit can fix single flips and catch doubles
	\end{itemize}
\item Drive Failure 
	\begin{itemize}
		\item this includes physical damage to the drive
		\item companies give an annualized fail rate to give \% fail chance for a year of operation
		\item we can use SMART to check condition metrics; f we find a bad sector, we have replacement ones
	\end{itemize}
\item User error
	\begin{itemize}
		\item ex) rm * .o (remove all files) instead of rm *.o  (remove all object files)
	\end{itemize}
\item OER Errors
	\begin{itemize}
		\item include configuration errors, which are the majority of errors
		\item application and OS errors also quality
	\end{itemize}
\end{enumerate}

We can catch and fix power failure with our old method. We can catch drive failure with a log structured file system, but to fix it we need to make a copy.


\subsection{Redundant Array of Independent Disks (RAID)}

RAID was originally developed to save money by aggregating many small drives into a large one
It is now one of our most useful memory tools!

\pgfmathparse{atan2(0,1)}
\ifdim\pgfmathresult pt=0pt % atan2(y, x)
  \tikzset{declare function={atanXY(\x,\y)=atan2(\y,\x);atanYX(\y,\x)=atan2(\y,\x);}}
\else                       % atan2(x, y)
  \tikzset{declare function={atanXY(\x,\y)=atan2(\x,\y);atanYX(\y,\x)=atan2(\x,\y);}}
\fi


\subsubsection*{RAID-0}
\begin{center}
\begin{tikzpicture}[font=\sffamily\small,
	mycylinder/.style={draw, shape=cylinder, left color=blue!30, right color=blue!60, middle color=blue!10, 
	minimum height=1cm, minimum width=3cm, aspect=1, shape border rotate=90, append after command={%
		let \p{cyl@center} = ($(\tikzlastnode.before top)!0.5! (\tikzlastnode.after top)$),
			\p{cyl@x}      = ($(\tikzlastnode.before top)-(\p{cyl@center})$),
			\p{cyl@y}      = ($(\tikzlastnode.top)       -(\p{cyl@center})$)
		in (\p{cyl@center}) edge[draw,double distance=1pt,double=gray!40!white, fill=blue!10, to path={
			ellipse [x radius=veclen(\p{cyl@x})-1\pgflinewidth,
				y radius=veclen(\p{cyl@y})-1\pgflinewidth,
				rotate=atanXY(\p{cyl@x})]}] () }}]
\node[thick, mycylinder, minimum height=2cm, minimum width=3cm, left color=gray!50, right color=gray!80, middle color=gray!30] (a) at (0,0){};
\coordinate (b) at ($(a.after top)!0.5!(a.before top)$);
\coordinate (c) at ($(a.north)!2!(b)$);
\node[thick, mycylinder, anchor=south, 
	label=center:{$A_7$}] (d) at (c){};
\coordinate (bb) at ($(d.after top)!0.5!(d.before top)$);
\coordinate (cc) at ($(d.north)!2!(bb)$);
\node[thick, mycylinder, anchor=south, 
	label=center:{$A_5$}] (e) at (cc){};
\coordinate (bbb) at ($(e.after top)!0.5!(e.before top)$);
\coordinate (ccc) at ($(e.north)!2!(bbb)$);
\node[thick, mycylinder, anchor=south, left color=red!30, right color=red!60, middle color=red!10,  
	label=center:{$A_3$}] (f) at (ccc){};
\coordinate (bbbb) at ($(f.after top)!0.5!(f.before top)$);
\coordinate (cccc) at ($(f.north)!2!(bbbb)$);
\node[thick, mycylinder, anchor=south, left color=red!30, right color=red!60, middle color=red!10,  
	label=center:{$A_1$}] (g) at (cccc){};

\node[right=2.25cm of a, thick, mycylinder, minimum height=2cm, minimum width=3cm, 
	left color=gray!50, right color=gray!80, middle color=gray!30] (aa) at (0,0){};
\coordinate (b) at ($(aa.after top)!0.5!(aa.before top)$);
\coordinate (c) at ($(aa.north)!2!(b)$);
\node[thick, mycylinder, anchor=south, 
	label=center:{$A_8$}] (d) at (c){};
\coordinate (bb) at ($(d.after top)!0.5!(d.before top)$);
\coordinate (cc) at ($(d.north)!2!(bb)$);
\node[thick, mycylinder, anchor=south, 
	label=center:{$A_6$}] (e) at (cc){};
\coordinate (bbb) at ($(e.after top)!0.5!(e.before top)$);
\coordinate (ccc) at ($(e.north)!2!(bbb)$);
\node[thick, mycylinder, anchor=south, left color=red!30, right color=red!60, middle color=red!10, 
	label=center:{$A_4$}] (f) at (ccc){};
\coordinate (bbbb) at ($(f.after top)!0.5!(f.before top)$);
\coordinate (cccc) at ($(f.north)!2!(bbbb)$);
\node[thick, mycylinder, anchor=south, left color=red!30, right color=red!60, middle color=red!10,  
	label=center:{$A_2$}] (g) at (cccc){};

\end{tikzpicture}
\end{center}
\begin{itemize}
	\item We concatenate physical disks to form a large virtual one.
	\item We stripe the data to increase concurrency for read and write.
\end{itemize}

\subsubsection*{RAID-1}

\begin{center}
\begin{tikzpicture}[font=\sffamily\small,
	mycylinder/.style={draw, shape=cylinder, minimum height=1cm, minimum width=3cm, 
	aspect=1, shape border rotate=90, append after command={%
		let \p{cyl@center} = ($(\tikzlastnode.before top)!0.5! (\tikzlastnode.after top)$),
			\p{cyl@x}      = ($(\tikzlastnode.before top)-(\p{cyl@center})$),
			\p{cyl@y}      = ($(\tikzlastnode.top)       -(\p{cyl@center})$)
		in (\p{cyl@center}) edge[draw,double distance=1pt,double=gray!40!white, fill=gray!10, to path={
			ellipse [x radius=veclen(\p{cyl@x})-1\pgflinewidth,
				y radius=veclen(\p{cyl@y})-1\pgflinewidth,
				rotate=atanXY(\p{cyl@x})]}] () }}]
\node[thick, mycylinder, minimum height=2cm, minimum width=3cm, left color=gray!50, right color=gray!80, middle color=gray!30] (a) at (0,0){};
\coordinate (b) at ($(a.after top)!0.5!(a.before top)$);
\coordinate (c) at ($(a.north)!2!(b)$);
\node[thick, mycylinder, anchor=south, left color=red!30, right color=red!60, middle color=red!10, 
	label=center:{$A_4$}] (d) at (c){};
\coordinate (bb) at ($(d.after top)!0.5!(d.before top)$);
\coordinate (cc) at ($(d.north)!2!(bb)$);
\node[thick, mycylinder, anchor=south, left color=red!30, right color=red!60, middle color=red!10, 
	label=center:{$A_3$}] (e) at (cc){};
\coordinate (bbb) at ($(e.after top)!0.5!(e.before top)$);
\coordinate (ccc) at ($(e.north)!2!(bbb)$);
\node[thick, mycylinder, anchor=south, left color=red!30, right color=red!60, middle color=red!10, 
	label=center:{$A_2$}] (f) at (ccc){};
\coordinate (bbbb) at ($(f.after top)!0.5!(f.before top)$);
\coordinate (cccc) at ($(f.north)!2!(bbbb)$);
\node[thick, mycylinder, anchor=south,left color=red!30, right color=red!60, middle color=red!10,  
	label=center:{$A_1$}] (g) at (cccc){};

\node[right=2.25cm of a, thick, mycylinder, minimum height=2cm, minimum width=3cm, 
	left color=gray!50, right color=gray!80, middle color=gray!30] (aa) at (0,0){};
\coordinate (b) at ($(aa.after top)!0.5!(aa.before top)$);
\coordinate (c) at ($(aa.north)!2!(b)$);
\node[thick, mycylinder, anchor=south, left color=red!30, right color=red!60, middle color=red!10, 
	label=center:{$A_4$}] (d) at (c){};
\coordinate (bb) at ($(d.after top)!0.5!(d.before top)$);
\coordinate (cc) at ($(d.north)!2!(bb)$);
\node[thick, mycylinder, anchor=south, left color=red!30, right color=red!60, middle color=red!10, 
label=center:{$A_3$}] (e) at (cc){};
\coordinate (bbb) at ($(e.after top)!0.5!(e.before top)$);
\coordinate (ccc) at ($(e.north)!2!(bbb)$);
\node[thick, mycylinder, anchor=south, left color=red!30, right color=red!60, middle color=red!10, 
	label=center:{$A_2$}] (f) at (ccc){};
\coordinate (bbbb) at ($(f.after top)!0.5!(f.before top)$);
\coordinate (cccc) at ($(f.north)!2!(bbbb)$);
\node[thick, mycylinder, anchor=south, left color=red!30, right color=red!60, middle color=red!10,  
	label=center:{$A_1$}] (g) at (cccc){};
\end{tikzpicture}
\end{center}

\begin{itemize}
	\item We mirror half of our disks.
	\item We double write speed and half storage.
	\item We can now survive with half our data lost.
\end{itemize}

\subsubsection*{RAID-4}

\begin{center}
\resizebox{.9\textwidth}{!}{
\begin{tikzpicture}[font=\sffamily\small,
	mycylinder/.style={draw, shape=cylinder, minimum height=1cm, minimum width=3cm, 
	aspect=1, shape border rotate=90, append after command={%
		let \p{cyl@center} = ($(\tikzlastnode.before top)!0.5! (\tikzlastnode.after top)$),
			\p{cyl@x}      = ($(\tikzlastnode.before top)-(\p{cyl@center})$),
			\p{cyl@y}      = ($(\tikzlastnode.top)       -(\p{cyl@center})$)
		in (\p{cyl@center}) edge[draw,double distance=1pt,double=gray!40!white, fill=gray!10, to path={
			ellipse [x radius=veclen(\p{cyl@x})-1\pgflinewidth,
				y radius=veclen(\p{cyl@y})-1\pgflinewidth,
				rotate=atanXY(\p{cyl@x})]}] () }}]
\node[thick, mycylinder, minimum height=2cm, minimum width=3cm, left color=gray!50, right color=gray!80, middle color=gray!30] (a) at (0,0){};
\coordinate (b) at ($(a.after top)!0.5!(a.before top)$);
\coordinate (c) at ($(a.north)!2!(b)$);
\node[thick, mycylinder, anchor=south, left color=blue!30, right color=blue!60, middle color=blue!10, 
	label=center:{$D_1$}] (d) at (c){};
\coordinate (bb) at ($(d.after top)!0.5!(d.before top)$);
\coordinate (cc) at ($(d.north)!2!(bb)$);
\node[thick, mycylinder, anchor=south, left color=green!30, right color=green!60, middle color=green!10, 
	label=center:{$C_1$}] (e) at (cc){};
\coordinate (bbb) at ($(e.after top)!0.5!(e.before top)$);
\coordinate (ccc) at ($(e.north)!2!(bbb)$);
\node[thick, mycylinder, anchor=south, left color=orange!30, right color=orange!60, middle color=orange!10, 
	label=center:{$B_1$}] (f) at (ccc){};
\coordinate (bbbb) at ($(f.after top)!0.5!(f.before top)$);
\coordinate (cccc) at ($(f.north)!2!(bbbb)$);
\node[thick, mycylinder, anchor=south,left color=red!30, right color=red!60, middle color=red!10,  
	label=center:{$A_1$}] (g) at (cccc){};

\node[right=2.25cm of a, thick, mycylinder, minimum height=2cm, minimum width=3cm, 
	left color=gray!50, right color=gray!80, middle color=gray!30] (aa) at (0,0){};
\coordinate (b) at ($(aa.after top)!0.5!(aa.before top)$);
\coordinate (c) at ($(aa.north)!2!(b)$);
\node[thick, mycylinder, anchor=south, left color=blue!30, right color=blue!60, middle color=blue!10, 
	label=center:{$D_2$}] (d) at (c){};
\coordinate (bb) at ($(d.after top)!0.5!(d.before top)$);
\coordinate (cc) at ($(d.north)!2!(bb)$);
\node[thick, mycylinder, anchor=south, left color=green!30, right color=green!60, middle color=green!10, 
label=center:{$C_2$}] (e) at (cc){};
\coordinate (bbb) at ($(e.after top)!0.5!(e.before top)$);
\coordinate (ccc) at ($(e.north)!2!(bbb)$);
\node[thick, mycylinder, anchor=south, left color=orange!30, right color=orange!60, middle color=orange!10, 
	label=center:{$B_2$}] (f) at (ccc){};
\coordinate (bbbb) at ($(f.after top)!0.5!(f.before top)$);
\coordinate (cccc) at ($(f.north)!2!(bbbb)$);
\node[thick, mycylinder, anchor=south, left color=red!30, right color=red!60, middle color=red!10,  
	label=center:{$A_2$}] (g) at (cccc){};

\node[right=6cm of a, thick, mycylinder, minimum height=2cm, minimum width=3cm, 
	left color=gray!50, right color=gray!80, middle color=gray!30] (aaa) at (0,0){};
\coordinate (b) at ($(aaa.after top)!0.5!(aaa.before top)$);
\coordinate (c) at ($(aaa.north)!2!(b)$);
\node[thick, mycylinder, anchor=south, left color=blue!30, right color=blue!60, middle color=blue!10, 
	label=center:{$D_3$}] (d) at (c){};
\coordinate (bb) at ($(d.after top)!0.5!(d.before top)$);
\coordinate (cc) at ($(d.north)!2!(bb)$);
\node[thick, mycylinder, anchor=south, left color=green!30, right color=green!60, middle color=green!10, 
label=center:{$C_3$}] (e) at (cc){};
\coordinate (bbb) at ($(e.after top)!0.5!(e.before top)$);
\coordinate (ccc) at ($(e.north)!2!(bbb)$);
\node[thick, mycylinder, anchor=south, left color=orange!30, right color=orange!60, middle color=orange!10, 
	label=center:{$B_3$}] (f) at (ccc){};
\coordinate (bbbb) at ($(f.after top)!0.5!(f.before top)$);
\coordinate (cccc) at ($(f.north)!2!(bbbb)$);
\node[thick, mycylinder, anchor=south, left color=red!30, right color=red!60, middle color=red!10,  
	label=center:{$A_3$}] (g) at (cccc){};

\node[right=9.75cm of a, thick, mycylinder, minimum height=2cm, minimum width=3cm, 
	left color=gray!50, right color=gray!80, middle color=gray!30] (aaa) at (0,0){};
\coordinate (b) at ($(aaa.after top)!0.5!(aaa.before top)$);
\coordinate (c) at ($(aaa.north)!2!(b)$);
\node[thick, mycylinder, anchor=south, left color=blue!30, right color=blue!60, middle color=blue!10, 
	label=center:{$D_P$}] (d) at (c){};
\coordinate (bb) at ($(d.after top)!0.5!(d.before top)$);
\coordinate (cc) at ($(d.north)!2!(bb)$);
\node[thick, mycylinder, anchor=south, left color=green!30, right color=green!60, middle color=green!10, 
	label=center:{$C_P$}] (e) at (cc){};
\coordinate (bbb) at ($(e.after top)!0.5!(e.before top)$);
\coordinate (ccc) at ($(e.north)!2!(bbb)$);
\node[thick, mycylinder, anchor=south, left color=orange!30, right color=orange!60, middle color=orange!10, 
	label=center:{$B_P$}] (f) at (ccc){};
\coordinate (bbbb) at ($(f.after top)!0.5!(f.before top)$);
\coordinate (cccc) at ($(f.north)!2!(bbbb)$);
\node[thick, mycylinder, anchor=south, left color=red!30, right color=red!60, middle color=red!10,  
	label=center:{$A_P$}] (g) at (cccc){};
\end{tikzpicture}
}
\end{center}
\begin{itemize}
\item We reserve one of our disks for \term{parity bits}. Parity bits are calculated with exclusive-or $(\oplus)$
\item When a drive fails, we go into degraded mode;
	\begin{itemize}
		\item We especially need to guarantee robustness here.
		\item We can use a hot spare to replace a corrupt drive.
		\item We can now add drives easily.
		\item We can now recover from a drive loss.
	\end{itemize}
\end{itemize}


\subsubsection*{RAID-5}

\begin{center}
\resizebox{.9\textwidth}{!}{
\begin{tikzpicture}[font=\sffamily\small,
	mycylinder/.style={draw, shape=cylinder, minimum height=1cm, minimum width=3cm, 
	aspect=1, shape border rotate=90, append after command={%
		let \p{cyl@center} = ($(\tikzlastnode.before top)!0.5! (\tikzlastnode.after top)$),
			\p{cyl@x}      = ($(\tikzlastnode.before top)-(\p{cyl@center})$),
			\p{cyl@y}      = ($(\tikzlastnode.top)       -(\p{cyl@center})$)
		in (\p{cyl@center}) edge[draw,double distance=1pt,double=gray!40!white, fill=gray!10, to path={
			ellipse [x radius=veclen(\p{cyl@x})-1\pgflinewidth,
				y radius=veclen(\p{cyl@y})-1\pgflinewidth,
				rotate=atanXY(\p{cyl@x})]}] () }}]
\node[thick, mycylinder, minimum height=2cm, minimum width=3cm, left color=gray!50, right color=gray!80, middle color=gray!30] (a) at (0,0){};
\coordinate (b) at ($(a.after top)!0.5!(a.before top)$);
\coordinate (c) at ($(a.north)!2!(b)$);
\node[thick, mycylinder, anchor=south, left color=blue!30, right color=blue!60, middle color=blue!10, 
	label=center:{$D_P$}] (d) at (c){};
\coordinate (bb) at ($(d.after top)!0.5!(d.before top)$);
\coordinate (cc) at ($(d.north)!2!(bb)$);
\node[thick, mycylinder, anchor=south, left color=green!30, right color=green!60, middle color=green!10, 
	label=center:{$C_1$}] (e) at (cc){};
\coordinate (bbb) at ($(e.after top)!0.5!(e.before top)$);
\coordinate (ccc) at ($(e.north)!2!(bbb)$);
\node[thick, mycylinder, anchor=south, left color=orange!30, right color=orange!60, middle color=orange!10, 
	label=center:{$B_1$}] (f) at (ccc){};
\coordinate (bbbb) at ($(f.after top)!0.5!(f.before top)$);
\coordinate (cccc) at ($(f.north)!2!(bbbb)$);
\node[thick, mycylinder, anchor=south,left color=red!30, right color=red!60, middle color=red!10,  
	label=center:{$A_1$}] (g) at (cccc){};

\node[right=2.25cm of a, thick, mycylinder, minimum height=2cm, minimum width=3cm, 
	left color=gray!50, right color=gray!80, middle color=gray!30] (aa) at (0,0){};
\coordinate (b) at ($(aa.after top)!0.5!(aa.before top)$);
\coordinate (c) at ($(aa.north)!2!(b)$);
\node[thick, mycylinder, anchor=south, left color=blue!30, right color=blue!60, middle color=blue!10, 
	label=center:{$D_2$}] (d) at (c){};
\coordinate (bb) at ($(d.after top)!0.5!(d.before top)$);
\coordinate (cc) at ($(d.north)!2!(bb)$);
\node[thick, mycylinder, anchor=south, left color=green!30, right color=green!60, middle color=green!10, 
label=center:{$C_P$}] (e) at (cc){};
\coordinate (bbb) at ($(e.after top)!0.5!(e.before top)$);
\coordinate (ccc) at ($(e.north)!2!(bbb)$);
\node[thick, mycylinder, anchor=south, left color=orange!30, right color=orange!60, middle color=orange!10, 
	label=center:{$B_2$}] (f) at (ccc){};
\coordinate (bbbb) at ($(f.after top)!0.5!(f.before top)$);
\coordinate (cccc) at ($(f.north)!2!(bbbb)$);
\node[thick, mycylinder, anchor=south, left color=red!30, right color=red!60, middle color=red!10,  
	label=center:{$A_2$}] (g) at (cccc){};

\node[right=6cm of a, thick, mycylinder, minimum height=2cm, minimum width=3cm, 
	left color=gray!50, right color=gray!80, middle color=gray!30] (aaa) at (0,0){};
\coordinate (b) at ($(aaa.after top)!0.5!(aaa.before top)$);
\coordinate (c) at ($(aaa.north)!2!(b)$);
\node[thick, mycylinder, anchor=south, left color=blue!30, right color=blue!60, middle color=blue!10, 
	label=center:{$D_3$}] (d) at (c){};
\coordinate (bb) at ($(d.after top)!0.5!(d.before top)$);
\coordinate (cc) at ($(d.north)!2!(bb)$);
\node[thick, mycylinder, anchor=south, left color=green!30, right color=green!60, middle color=green!10, 
label=center:{$C_3$}] (e) at (cc){};
\coordinate (bbb) at ($(e.after top)!0.5!(e.before top)$);
\coordinate (ccc) at ($(e.north)!2!(bbb)$);
\node[thick, mycylinder, anchor=south, left color=orange!30, right color=orange!60, middle color=orange!10, 
	label=center:{$B_P$}] (f) at (ccc){};
\coordinate (bbbb) at ($(f.after top)!0.5!(f.before top)$);
\coordinate (cccc) at ($(f.north)!2!(bbbb)$);
\node[thick, mycylinder, anchor=south, left color=red!30, right color=red!60, middle color=red!10,  
	label=center:{$A_3$}] (g) at (cccc){};

\node[right=9.75cm of a, thick, mycylinder, minimum height=2cm, minimum width=3cm, 
	left color=gray!50, right color=gray!80, middle color=gray!30] (aaa) at (0,0){};
\coordinate (b) at ($(aaa.after top)!0.5!(aaa.before top)$);
\coordinate (c) at ($(aaa.north)!2!(b)$);
\node[thick, mycylinder, anchor=south, left color=blue!30, right color=blue!60, middle color=blue!10, 
	label=center:{$D_4$}] (d) at (c){};
\coordinate (bb) at ($(d.after top)!0.5!(d.before top)$);
\coordinate (cc) at ($(d.north)!2!(bb)$);
\node[thick, mycylinder, anchor=south, left color=green!30, right color=green!60, middle color=green!10, 
	label=center:{$C_4$}] (e) at (cc){};
\coordinate (bbb) at ($(e.after top)!0.5!(e.before top)$);
\coordinate (ccc) at ($(e.north)!2!(bbb)$);
\node[thick, mycylinder, anchor=south, left color=orange!30, right color=orange!60, middle color=orange!10, 
	label=center:{$B_4$}] (f) at (ccc){};
\coordinate (bbbb) at ($(f.after top)!0.5!(f.before top)$);
\coordinate (cccc) at ($(f.north)!2!(bbbb)$);
\node[thick, mycylinder, anchor=south, left color=red!30, right color=red!60, middle color=red!10,  
	label=center:{$A_P$}] (g) at (cccc){};
\end{tikzpicture}
}
\end{center}
\begin{itemize}
\item We stripe within a RAID 4 system.
\item This is faster but more difficult to add drives.
\item The book says these have almost entirely replaced RAID 4, but Eggert now seems to disagree.
\end{itemize}

All RAID uses a full-stop model; on detection of an error the operation stops. It can use checksums that include the data location


\end{document}