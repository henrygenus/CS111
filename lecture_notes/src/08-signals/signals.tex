\documentclass[../../lecture_notes.tex]{subfiles}
\begin{document}


Why do we use signals?
\begin{itemize} 
\item asynchronous I/O with aread() 
	\begin{itemize} [nosep]
	\item returns right away and kernel keeps going with handling the data
	\item get a SIGIO signal later
	\end{itemize}
\item error in your code (SIGFPE)
	\begin{itemize} [nosep]
	\item divide by zero
	\item floating point overflow
	\item invalid instruction
	\end{itemize}
\item impatient user of infinite loop (SIGINT)
	\begin{itemize} [nosep]
	\item \^{}C to end program
    	\end{itemize}
\item impending power outage (SIGPWR)
	\begin{itemize} [nosep]
	\item So we can do any saving before shutdown
    	\end{itemize}
\item to check for dying children (SIGCHLD)
	\begin{itemize} [nosep]
	\item p = waitpid(-1, \&status, WNOHANG)
	\item now we don't have to call this method every 100 milliseconds
    	\end{itemize}
\item user went away (SIGHUP)
\item alarms
	\begin{itemize} [nosep]
	\item alarms are not inherited by fork() but by execvp()
    	\end{itemize}
\item suspending a process
	\begin{itemize} [nosep]
	\item \$ kill -STOP 29; kill -CONT 29
    	\end{itemize}
\item kill the program SIGKILL
	\begin{itemize} [nosep]
	\item cannot be caught or ignored
    	\end{itemize}
\end{itemize}

We can kill a process with:
\begin{lstlisting}[language=sh]
while (fork()) continue;
$ kill -KILL 29316       # does not kill children
# however this does not kill the shell bomb
$ kill -KILL -29316      # kills all children as well  
\end{lstlisting}


Code must often be developed specifically to be able to handle signals; take the code
\begin{lstlisting}
fd = open("foo", O_RDONLY);
fo = open("foo.gz", O_WRONLY);
while (compress(fd, fo)) continue;
close(fo);
unlink("foo");
// THIS CODE IS NOT ATOMIC AND CAN BE INTERRUPTED BY A SIGNAL
\end{lstlisting}


We can attempt to avoid these errors by implementing a signal handler
\begin{lstlisting}
static void cleanup (int sig) {
	unlink("foo.gz");    
	_exit(1);            
}
int main(){... 
	fd = open("foo", O_RDONLY);
	signal(SIGINT, cleanup);*
	fo = open("foo.gz", O_WRONLY);
	while (compress(fd, fo)) continue;
	close(fo);
	signal(SIGINT, SIG_DFL);*
	unlink("foo");
...}
\end{lstlisting}
but this still leaves race conditions .


In our current implementation, all threads are affected by the sign. Should all threads handle the signal? Would all threads handle it the same? NO; threads have their own signal mask to ignore signals. This is why pthread\_sigmask() affects only current thread!


So how do we handle them? By default threads have their signals blocked. We use pthread\_sigmask() to unblock the signal if we want a thread to handle it. Linux picks one random thread to deliver the signal. We make a mask with
\begin{lstlisting}
int pthread_sigmask(int how, const sigset_t *set, sigset_t *oldset);
// how = SIG_BLOCK, SIG_SCIMAKS, SIG_UNBLOCK
\end{lstlisting}
this allows the signal to arrive even before function returns. With this, we can build critical sections such as
\begin{lstlisting}
sigset_t ss;
sigemptyset(&ss);
sigaddset(&ss, SIGINT);
pthread_sigmask(SIG_BLOCK, &ss, 0);
// critical section here .......
pthread_sigmask(SIG_UNBLOCK, &ss, 0);
\end{lstlisting}

But how can a signal handler manage memory access?
\begin{lstlisting}
void handle_interrupt(int sig) {
	fprintf(stderr, "Interrupted\n");
	unlink(...);
}
fprintf(...) { malloc(...); } // interrupt
malloc(...) { // operating on heap }
// if we interrupt malloc and fprintf will call malloc again
// the second malloc may corrupt the heap, thus the first malloc call
\end{lstlisting}


Only some system calls can safely be used in handlers!
We can call most system calls, such as:
\begin{itemize}
\item \_exit()
\item write()
\end{itemize}
But there are exceptions:
\begin{itemize}
\item exit() (calls malloc, flushes I/O buffer)
\item fprintf()
\item malloc()
\end{itemize}

We can perform all system calls in a single handler with:
\begin{lstlisting}
void handle_interrupt(int sig) {
if (pthread_self() == stgmgr) really_handle_interrupt();
else pthread_kill(SIGINT, stgmgr); // forward signal to stage manager
}

# a more conservative approach is to set the variable and handle outside
sig_atomic_t volatile globv;
void handle_interrupt(int sig) {
	global = 1;
}
// always memory access, no cache!
\end{lstlisting}


But even with our scrupulous effort, interrupts can still cause difficulty:
\begin{lstlisting}
read("/dev/tty", buf, 100);
// SIGHUP signal arrives
// run SIGHUP handler
// returns and continue reading
\end{lstlisting}


This means we have to complicate our code:
\begin{lstlisting}
while (read("/dev/tty", buf, 100) == -1 && errno == EINTR) continue;
\end{lstlisting}


These types of errors are common with long system calls; clearly scheduling concurrent threads properly is important.


\end{document}