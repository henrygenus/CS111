\documentclass[../../lecture_notes.tex]{subfiles}
\begin{document}


\begin{lstlisting}[language=BASH]
$ ls -l big
-rw-r--r-- 1 eggert faculty 9000000000000000000 Sep 21 11:31 big
$ grep x big
$ time grep x big
real 0m0.009s
\end{lstlisting}

The grep command here analyzes roughly 1021 bytes/second…which is unrealistically fast!
How is this possible?….. big is a sparse file! (generated from \$ truncate … big)
grep “cheated”, in a sense, by knowing the file was empty.

However…
\begin{lstlisting}[language=BASH]
$ grep -r
\end{lstlisting}
does not skip sparse files, so it can be stalled…and it is used by the NSA!

Clearly, Operating System choices are important.

How do we define an Operating System?
\begin{itemize}
\item American Heritage; 4th Edition (2000) $\coloneqq$ Software designed to control the hardware of a specific data processing system input and output to allow users and applications to make use. Note that this definition wouldn’t include Linux, since it works on most hardware!
\item Encarta (2007) $\coloneqq$ the master control program in a computer
\item Wikipedia v. 917297650 $\coloneqq$ system software that manages computer hardware and software resources and provides common services for computer programs
\end{itemize}

Thus we can see that the definition has moved from control to user-environment interaction facilitation
We can get our goals from this information!

What are the goals of an Operating System?
\begin{itemize}
\item External Goals:
	\begin{itemize}
	\item protection (from hackers and bugs)
	\item robustness (in unforeseen circumstances)
	\item utilization (time wise; always working)
	\item performance (time/memory/energy)
	\end{itemize}
\item Internal Goals:
	\begin{itemize}
	\item simplicity (complexity = cost)
	\item flexibility (easy to mutate)
	\end{itemize}
\end{itemize}
BUT systems have their downsides…


\begin{enumerate}
\item TRADEOFFS
	\begin{itemize}
	\item \term{Waterbed Effect} --- fixing a problem causes another unrelated one
	\item \term{Binary Classification} --- when we must classify binary items by proxy.
		Less errors of one type means more of another!
	\item Say we want to sort 6 million records of 1024 bytes.
		6 million records take ~6GB!  We need to be more space efficient! SO we use a pointer array! 
		Copying is now $2^7$ times faster, but we sacrificed simplicity! 
		(we must edit our software to use pointers)
	\item The moral of the story is NOTHING IS FREE 
	\end{itemize}
\item INCOMMENSURATE SCALING
\begin{itemize}
	\item Not all parts of a system grow at the same rate.
	\item There are two common types: 
		\begin{itemize}
			\item\term{Economies of Scale}: Big = Fast (think: factory)
			\item\term{Diseconomies of Scale}: Small = Fast (think: STAR network)
		\end{itemize}
	\end{itemize}
\item EMERGENT PROPERTIES
	\begin{itemize}
	\item Systems sometimes have properties that are not present in any individual members
	\item ex) Napster and Torrents: UCLA received a network speed boost, but this resulted in an increase in music torrenting!
	\end{itemize}
\item PROPAGATION OF EFFECTS
	\begin{itemize}
	\item ex) Shift-JIS --- str: ab\begin{CJK}{UTF8}{min}練\end{CJK}c = a | b | / | … | c\\
		Japanese characters had to be modeled as two byte characters, but some filenames failed since the arbitrary bits could look like a slash! We cannot always predict the consequences of a chance in all areas of the system.
	\end{itemize}
\end{enumerate}

More broadly, systems introduce a lot of complexity. Complexity is hard to define, so we look for benchmarks:
\begin{enumerate}[label=(\roman*)]
	\item a large number of components
	\item a large number of interconnections
	\item a large number of irregularities
	\item a team of designers, implementers, or maintainers
	\item a long \term{Kolmogorov Complexity}\\
                        Kolmogorov Complexity $\coloneqq$ the length of the shortest description.
\end{enumerate}
Not all signs are necessary for a system to be complex!


We can generalize our problems to a few major Operating System goals:
\begin{itemize}
	\item virtualization
	\item concurrency
	\item persistence
\end{itemize}
    (and if it were up to Eggert)
\begin{itemize}
	\item evolution
	\item flexibility
\end{itemize}
Notice that these are contradictory…especially eggert’s!

But why even use an OS? Well...let's try to make an application without one!


\end{document}